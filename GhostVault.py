# Базовые модули Python
import os  # Работа с файловой системой: проверка существования файлов, удаление, работа с путями.
import io  # Работа с потоками данных в памяти (например, для работы с изображениями).
import random  # Генерация случайных чисел, выбор случайных элементов (например, для генерации ключей).
import threading  # Многопоточность: выполнение задач параллельно (например, проверка новых сообщений).
from datetime import datetime, timezone
import tkinter as tk  # Создание графического интерфейса, используется для вызова окна выбора файлов.
from tkinter import filedialog  # Модуль для создания диалогов выбора файлов и директорий.
import time  # Работа с временем, например, для создания задержек (sleep) или измерения времени выполнения.
from queue import Queue  # Потокобезопасная очередь для передачи данных между потоками.
import subprocess # Модуль для запуска системных процессов и выполнения команд ОС
import json # Модуль для работы с json файлами
import zipfile  # Работа с ZIP-архивами: сжатие и распаковка файлов.
from pathlib import Path  # Упрощенная работа с файловой системой, удобное управление путями.
import requests  # Отправка HTTP-запросов: получение данных с веб-серверов, работа с API.
import sys  # Доступ к системным параметрам и аргументам командной строки.
import pytz  # Работа с часовыми поясами: конвертация времени между разными зонами.

# Библиотеки сторонние
import PySimpleGUI as sg  # Библиотека для создания графического интерфейса (окон, кнопок, полей ввода и т.д.).
import psycopg2  # Работа с базой данных PostgreSQL: подключение, выполнение SQL-запросов, управление транзакциями.
import pyperclip  # Работа с буфером обмена (копирование текста в clipboard).
from cryptography.fernet import Fernet  # Шифрование и дешифрование данных для обеспечения безопасности.
from PIL import Image, ImageOps  # Работа с изображениями:
# - Image: открытие, изменение, сохранение изображений.
# - ImageOps: дополнительные операции с изображениями, например, изменение размера.
from playsound import playsound  # Воспроизведение звуков (например, уведомления) без сложных настроек.

# Константы
POSTGRESQL_URL = "https://www.dropbox.com/scl/fi/cjdit048dvc6kz9g2oiir/postgresql-portable-main.zip?rlkey=3dsgoatqy6989vxa53orp08nv&st=cqpihygs&dl=1"
sg.set_options(icon=b'iVBORw0KGgoAAAANSUhEUgAAAH4AAAB+CAYAAADiI6WIAAAAAXNSR0IArs4c6QAAAA5lWElmTU0AKgAAAAgAAAAAAAAA0lOTAABAAElEQVR4Ad1dB2BVRdY+r6USWugkECCU0ERQQYqCqCgoCAqigICI2Na+upZdd1172bWLDZVepAlI7x1p0kkhkIQOoSQh7ZX/+2be5N08AhJA/9VJ7rtt6mlz5syZuSJ/0pAUHx+aWaNuLZ+IvTRNZPzjNerFHqhep/b2Jk1CSpP2jxTX9keq7IXW9Whs3asq7N29Ju1wmmPHtt2eUd9PTD92NFM8eR7Zl5ouBW632D3IzeEQLzBdJipcYmJrit1pk4aN69bq0/cOe+MmCVIuMsp7Mjbhkcr7U7640LL/KPH+dIj3gdN9SYl5jRteLdn5+WIDgj1er4jNDYTni8/nE4/4xOlwis3uE6/HJw6nU+x2p7jsIeIsdIjb5xG3PVfsjkgQygavo258pG3v3rw/ClIvpJ7OC4n0R4pz/Iy9TnjhGckqyJf0vavFLRpfWt6DABBsPjtQjyc2fW9tn3nixftaNTtKdmGe3etxDkGcT63x/ujXfzrE2xzeti/9/VXx2W1S6CsUB5B7xmOXlORUSUpMlZwzOcC3T9yQAmB+CQsLlbi6MVIvrrZUrVixCJ92KVBS4KFHnpSx+xI/ORzXaHbVtMQ9RRH+4Bd/KsRnxtZrWn5f4jfrOvUUm80Gke6R1NQU2fLLEXFQvNtDpVx4qPjYsSN4xIvndjmSdgrHFhCCV9grtGxZX+LqVEBXUCibft4BySAS4pGoPziui1W/VBpvsZT/gzc2r8PhBToPHzwub3/wd4XsTRuS1NkGCWCCF5c8bDanOpt7nu2AyPrNW0ESNqlSo4zknMhHd+EB//+5wp8K8UTN4SPHpbAgT7rfdrPqw12OMuBcm+JycjoPO6SBPngNnvcfNhv6fmDe43VBDrhkzLf/UZTw99fekhBv4ck/E+r/VIgnV7755gfiwXAtxAetXaDVg6tNKOJsdu4qBJrPrsEQRIgzHJq9W+o3iFVdxpyZi8TjdHQz+fwZzoGW/8FbA1RScN+wYvnP4nU5IMsLZNnK9WiV0dOLN9BbhHz/cwz3TLCjb18wf6U4KPehHJ48ki0V0nZ/ejg2vp6J80c//2kQn1krvnH59F3/OXkyRwqdeeK1F0jmIY1Mindy+/mDXXUJKg6kRW6uCyQDUgIBFbgLYegJppTz5/a//vb/BfHkzt8CMOjBYZAR2b19uTjRXzts4UXFwFZTQqA00Ifp/3UkjOIh+hme+8fD0PZtsislyeb0ou+4zAHVYtV+dzz8rgVm1GwUnZufO+fRJ186tHnntqSjMfEdLyccFy5aBs7OlwiXC9linG4rVNkrboeCZ/rwCy3TAY7v3+cWpRA+/OgL0PhtN15o2l+Lx/mAM3m5e5595p8FX4wcVej2upNPxNa/7rdiiuD6/G6IP14zPubbJwZmNGzUocukcdOqdOl4R/zOyWMWH4+pf2dwpS7qHuPsjz/9Vgrt+bDD2+TkydMQ9xiXlyBbLowA7LJt5y4pE+EUd6FHjuw/IeXSdn8Lib8KBHv9xSKI6TJjGnTdMvHblISmN9QZO3aC459/e9Xe4pou9SL2bV8K8bL/RM0GV1wUDEqR6HdBPIAVcVNsnaThn08OGzS0q2QcXCrOUKfc1WOwdKwSN8njK/z34VoN6pYWmIyPvJ0PPPbsqzdG11u+7ufNcloKoYnnyZx5ywRjs1KAIjiqV3YnZqiHzVs1ksxjmVI37hrpdEOva2e8+8YSr89z5HhMvaGHq9SpeqH1Plo7oTqMRAe6120w6/4Bf3N9+f2LknpgmSTvX41h6CGJr3udPP3yK9XLZezadKJm/RbBNbqc9yXww+XMHrD3+aq1bHnLvowTh0P2pE6XEIyPHejiqTitWpUk9/R+SMqVrSI/b54ikaFlDp+qUa91hYOp+85VCwVkn8/xr7fevX/21AVv7j94tLwbA/AC72mZv3q8XBGDIRhMLmPGL4E5NgxEYC/qr02eyphDoqCt3hAHrtnPWwM1/1492qhHMPTK+x99IyP+Ox7JYBXE9F7D+vHywadv+5rE1z98IiZhQLRkr7IdOJCLBMUzwgNKvJSZk5KH3vfX0COnM2V7ykQp4whTcwYOwIRdU4P6t0kuJpJaXJkgs6aM852MrdeiYkbqFlWBy/zzmyL+BOa0gcQ9V97Ywb5u/hQ0skDO5OTKxPErpN/ALpghw7ALoX7tm6UAM2ItWjSVmTNG+U7VbNg++kDKKmtbydmfj/hy2McfjXrlZObpaLvDa69WP0LWzpuKaByzk7vtAJ9d9qany+afE5W93mHXZZi8rBY888ycS0J85Youad2mlThcIWL3aksfSxk1dZK89OT7IBabhIa5pE27dvLdtx/5QuzOA6fjGnQvvy95Y1G+Pl/1Xn3uT/1lc3JodIxXVi6agle5snbFdtmbckpc4W7pddctSs178JFXZe70pRJZLkK2blvuPVOnSfPotOTtJq/Ldf7NEE9HiPrJyYdQ0fIF3kPgOo/MmrFKsnP0uJp28e492wNorIJdRo2ZJf94/hMpExkiW3et9J2Ka3Rd5bQ9q7KrxUdP/s9rT7z5+od/O52VBVJxyodfPyU9boJlDtfoxRUsFs3fLKdOnMScugsI1wwXzO3nQ7rKBD9W5JPjraMBL4YMN9x8pZSLqIShHwgN0uKUN0ca1GsjYYV2cYaESaPmjWXq1NG+nNqNX7T5ZGn59N1j2l13R9yRw8dsq7eNlGgXJoLQFc2csVjcBWEYLlLS2KQAM4p9+ndRef78S5LcedvDEhrqkt0pqzw5NZo2q3Qwaaep4+U4/yaIT4+JCY/NyEhEBWPyPScxOZIn4yfMEZfTzHPAEu4fLoWEeaVb13aIapc8t11q1+ggkWGR8uWo96Vzh+u9LVpdb8vMPGkLdTpk2txPJCG+Prib/O2V09kemTNrhYSEUFQSZhDrwDkVOipwF4JolTDox4p884r5QeoowigoLJBqVctIhw5tUaiWAoVAZsOGncWb7UU77dJzQA8Z2Le39Lv7cTmelyNpKdPF4QuVQk+2zPhxFeb+gXRk7sUMIoNGfp70vruLgs2xzNNyRdPbQUzhkrxnhedMrSaNK+/fQ5helnBZEX8opm6zCik7R4aGhjZB7Vx5hUfg5VIoP/6wXGxwfCByGWxghWIBYr57r7Z4y97fKdVj2mIcDqcIDMFcEW7ZvHOORPjCMTxjT2iX6VPni7cQyIeFzk5RbvppxGeDTO7BiDfEZsomIksK50M843s9HmiVmO+DWRf8Kp1uvFoqRFWA8waMQJj/f/bv78gPYxeI0+0UT1S+7PtltmD+CC1zyeRJi9FtcC5AyypMECuCYr5EvhfH7Xd0EDA7rl0SU7O98hLak76+wBvfIqH8ZZoavmyI57DMsWP9pPJly6k88zyHgRS3TJm8FIaUkCIOVw2kmFTBf/YUovE2ue2Oduj3IV7R+MZXdpftv0zDcxpiBNqBU8aP/kmiIssiJQAPpY2INcgkUZCe1NkvTfyFnPdkkF+UTwnEYAjBCiySjLnne3e+W9rfcIVUrhyNNyQAt8TUbi/7UxdDAtHxwyk/Tl2CRJz3A4HjGQO7PGtQUgWN6NGzrWqbzxYlNau3BCGEStK+9fmn6zRLqLZvd6o1zcVcm7pfTNqiNNBY7zq65KdJvfsMla2blkJR26+odObUlWioVq5MQ5mIolhzf6DRNtXXOSSv8Jj07RsY2ufl+WTKlHkSHkruBkAJMCKcB6GPc3AwSAx+HnxvkB783NwXvQdiWZQJVklihJey/SNefn6hJDSuLM2aNldIZuvHT5mrxDzrpQ9D+DpHDQ+TO85wB2PZXbq1QrcXiluX1EQX6AhxSMbezYXZNevXP9/Ix5LTOS/Phto5o5b84nhsfJdye3fNaX7lzXKi4JikblkEXOfLjGlL0fDQokRWxPPhWY3FMyKfyo4rPE9u63qLjB+zUMIjwvAGLhOoKfMwfbcaEpZQ+wtBOqWC6h6Chm94WjxwiOeXAEaaFI8QuFNSAflRAaSPn6cwX/re01Wm/ThPvG7CAXn5iZTOHyW13zCDgQOJqeedrZXETN6XLe3b9YJEKSNbNiwrPFW7SZ1KGYn7AzUo3VUJoLvwDHzS0VngmXemWePOrmPuw3Jg5ypMkeXI3FkbpCAf3GzhxrMRT6oPcLwplaKPCpqdQz2IeR/H2v5gOM2KXKN1G0Ba3zGZvkc+0CNMUIjnDXUDP/KZvkgxLKFeJq31bIhCZUWkGyKh9MI19Q/WmURh6mdNH7g2EsDSVj8TkIh63HGVODEamDptpTzy6HNSpXJl2b55cTJg2gjVDjQskOGvXl0S4o/G1L+3/5Wtx2z6ZYckJf0okMayctlWOZHJuQzMjJ0D8XCBg5guGfGsMRGgkMw4DrZLAyYYqSYuzwQs3/NQ/bxVNpPDHHZJ3JWqRDEVRJMX/e9cVBLB0tHR5SQiMkLCQvR7E4f5M1gRXeK9n4hITHTrIrE7WJ/zIJ4STAUSuIIJaVEPI8kEbiiSECFy5903IccQqVGztYr38fBXpMsjL/SJ3p88SWdQut+LRnxmbIMOY//x3JJX//WBfffeORIGyO/amSYpKQfOApBGiEaelRi8RaxnKg2UABDmOBeXGIRoDtVcYoMuoaQKuKwQtvXUtAOSmw9OQ+9M1QoiRBWSD5drHgRoYV6+RIWGS9mK5RW1RUCBoiLmxnCNgQqntzBLYmtVl0j46lmDIQIjceiyzaBEPs4GsOppCYjXCPfDpCQJ4yciIp/dX35BDrqO3uLxuOH920lCwj2yZ896X15MkyplDyQeU4WX4ifgnlKKRKdrNKhUJm3X0ok39rL5QI2RngjJ85yWtLSjSkSz8VZtleNrowQFimGjA2xJjiO4FKcD+UboGSQH0ukrilEOieBnp8pcsm4zRgQREhIWIa7QEChEDlm+epWsW7ISpmCYRsFFXtSVyKR+UIh5dnKWGwWxbKcaikGf8GJ4hdFIgbdQunS9Va5u31r2HToDzs2Rk8cOSOurmqIClAi6hqRd5o2a+yvmP0FBw1yR6kpKJmC2n3kY5Ot0bD9B4Wd+5Mr24ddRTn6YMlV69+wmIaBBRbw+jy0vpOCicHhRiUhhx2s1+CG67fW9OfYcOW6eVK5SBpVFS9EWVt6LmlNJIRcSpabx1mYWiTnVZgCPjTaiT8Oh2K/1neJ2ZLZ1V5p4YPCJiq4BkW2Xt19+XSJDIhQySBzlILqdmKXrDEtfZPmyIIgCVR/ihPVy4M8DhcwB4HogBTIyDsiKBcvFBWQunrNAli1cijohDojhyZf+Klt3HMLQyi116tYUlzI5s43auMPKGgJne1kGka8lE99ag0Y6F3UEjehUJNNWwojlOzCpVSY0Wl5/bxJos0CN89mlXGy4KMSrwrzy9BtvvtS7fbvukoOlSceSjmN2qTwASEUK/Sa6psISOZ2pz6Z2xelBrTCND5y1ZY5ie/P2VGQTJvbwcvLfN1+TSK/ul8vAOHLNtQkS17gBaNClDEdELoFEXzyfF+7VUPQ8qBuplLCzs864c2FFTd34OlKvfn39DkTrhEPXzOkzJfPwUfn4tXfRvhDpeOuNcgaiogx0A47X6zWIU0ROaWK6MtVlAw6mK7A2LUDwRD4QS4axhMB7ZId6UmKybmvh6v39t9+LB0Q68NF+EuZk12RIzZLBBVwWL/ECEpgoJ+IaxZVL3ZFaJ/4a2JkLZNjjj4gDnNO0cayKQuSr/g6QNdzOF7pRGuik9kDQiDNINs95T6lhgLFx42YJi6pO3Mtrr/xLIkLLALheKV+lvNzeo7vkwXeOvTrmcGBNtUtoSKScOpkpP0JMegtgaUMdCSo7EKpAhoxMmR5Ihqgy5eSOO29XxRcgLsvFFKw4kd/pnGz5YeJ4CbFHoU1eaXN9e7m6aRN0MW5pEA/kqwV5/pr7uZHdC8PZMNDxgpHOpyQnUydKLQeUzeVrt0FyhcmXn32O8kLQv6+T7NqN7qmYnjJe51S634tGPIvBfPTY0X9/6Z53X/9EevbrLRXLVZQrm9UA9QeQXUQAQfWi+ELEYk81kgNV4j1n1wic7Tt3wzAUqTjq/X+9rqZcyQ19+/URrxPr38DpeAm7fZQsW7ZCkrZsxZw/ZtSQhwqoU5EChkc2JV81sZlKmLh6xMGnqB/K7nr7bSC2CKWh85nHkyfjRk6EyRhWRCA2IjpcHurXF/1urjRqGg8E6RxV2/2IJ4kHWmbVbnRc/rKdmiih4CqJBCmEdtlc4TJ3wRo5eOSwLJ47X669oYV8tWDViEoZyUMCqUt3Za1L6VIi9tHYhjUq7tu+v+lVt0vm/j0y5LHHwW0F0rplA1Cstj6pxhvuDyrBSu2Gwkntqn/0czqRuXXbTrFFlJPp06fJ3p2pEgqe6NW3J5ANSYB+1geLVh4WO04eOwmLJLVGzqKYp7V/ZV0Y9Ji+ONJN+Qb5jGfG5US2HZMxTljRbrurJ4wzWF4F5Y9xx4/B/DyI2B4WJQ89eB+IA/P09eLEFeLndOg5DEQoewJzHcibtKVf8D3j0buXCh2R78BIY96iTSrt6JEjoVeI7ElaL1m1m8b8vxlw2AhY7iaEpmzp07B+W8WFd903APMyp+Wa1s3QCOjd1JLPgXjTYHKVQTjP7NMYnJgD37J1j7gh6oe/+188scu1Ha6RmnExSAKFC8CdMHqmkjCBcYBKWuzHINUgni/NtXlnztaEJg6f6fdEIroQUOZd9/ZWeRDR1OAmjJugupjON3eWxk3iJevYMWnTtjniWHjLL/4NPEj4RhIUlY9nlBhKxAMOi1ZsBDzKIP+xWOadKyvWzZKoljcMrrQ/6TvW62LDxSt3pkSvPBPhCusTGxsnGWl7gARwnBNaNYDjJ2QTs9jZAg7FlQQCFzhyubKSFqD0X6DAZZ0pkO8+HQ4lyyW97+sOysdyRkDr2NFjsnzhKpWGMtTPzChDI8daGLxjlRTBZJmUK1dO6taNkwqVolU5+WfOYMnVIayszZCC3AIsmcaaeSqmCo1cW4d7lT9GHSibgX355PEQ9XDM6Hl3dzzxyJ2Ygh35/ShZtGiBLF++Qh5/Yphs27RPmrWMx3vWCemQJ5Gu7pCVQbp66f+hvkLi4mymMwT+ft5I8WHiqhC2h0iMUGpXqSknfZ5F1jQXc22F/8WkV2kwSTO+bPqOuxvUbye5BWdk8IMPYMhRKG2uweys31RqlBxToKJwIJuBXK5FGyYuIeKSMk7J8Ry3fA4u9+ZjmTPmugc80B8Ad4G57DLuuwkqnf7RQNXXfq3fD+jajeKkdefrATyCGDo+gOnDTCD7TSpIXs4EgqtozFHXVOaIaHDpCWjxU8dMhOEwBBznBIExDx0Md+puxCt16tWV5i2uAKfa1Grc2TPnwXQdLi/8bZgUZsFRIyEeCKcNH1oGpR+pFHVS5+A8wS1Uel3w6pkwcanENm4sX374ERxI3ZK4d40UxDZ7IDoj+RtTl4s9GzxcbHqVDs2wnYiJf37r+O/f7Hfvw3Jrz+5SJbqC5GFJcvv22mewqJFosAEcRTyvDeKdDpfkYSL6l20H5T9vvi1h6Co6dmorNeKqgjTCZOnCJXLgwGGUZpBtzqyG5kaP54z0exQ6D2fzIILdFAdwBOl64xXSoemVKAuOD+ivGeh7T8ueMuHizbHcHJmxfBkskEdU9wEKAev75OelqyV5y66iMlRi/OjuKVCH3nf3UQguAHdO/3EmpJNLXn35GYwqDkP8NxK3m4jXlrhgxDNPAxcalDZs2CHu8nEy+ssvpCD7lFSqV8W7ODH10cr7k4ab8i/lfFkQzwoQ+cdj4rPalascmX06R55/4y8yrH9nTNjshCDUlG4qSoAxsKH6AJ9hyLJyPRxMwsrKiI+GYwMLuGb1ukUiIuC04AyRsaPRhxbJcwKb3B0AOjm218P9xYkOshDIqhZTXv7WtwdKIqcG4rHcQNDEou9NHJ7hVQMOXZWyV6bNXI489Ighcf1W2bJivbIBBJRGbcAxhHdHDwwF0bd4Ct3wtJmLvLzy6quvyMnjB6VRQl2MCIj4AOdzyBuMBD676eZWkpVdIFdfe694CnLdh9K3lAGsLtuCjuAyAzAp5RU3CkrYtjWvWYvrbUdPnZC0HfNgXPHCz26D0lqDtVhD3QbxtrBw2fBLmnz8wYfgbZvczb4TSHTD9Drlhx8UwFgloywZpFMC3z6guzijYTnEJEb9BtXkwVuv83OzFt0lN8WKdBPDIF/fs840ja5KTZVZ87aobiEURDD+/eGKlLTeFshHt8krCRjb10+Ig65gh/PFLAgOh7z4whNA/glp1Lg+2kB7gi6LxKzsHf4qECE0NLXt0FzKV4iCUexWEH6YO2PP6suK+ECtTdsv8lz1VMGV6RkZtlOYmUtMXalE7ZQfVigupXJkDVakczjmxbBs/dZUmTRpAjcgkNt63KQUGgJ+8sRJfsCwqjw4tCLQoADh+s7H7xFXuXDJgph+78lB8mjXjkC6Lo399aUEjjrC4aLdOSFB3nmiJyTJcTV0vPulxyQHuozus8m95qD9wi47d+ySg2n0NRTYAG4BIkX+/e//Snh4pKxfuxFSDtIKuoUmeuo3HL7h3t/1wTwoyxb/ApHohsI8H5NGhc6efR/YdiltCU4bhJLg1xd+j75raeMmna475s2UvduWypbN6+XgfkxuoIHBgcoLe3YqdBwDb045jPnlrbJ89iKJb1Jbml/ZFCbKcBmPcTmRTy43HM68uELG7oKTwqC7IRFCZcjQbtIcOkXR8LBYgWeXX+x10Y2V24PT6HfssvKhH/xzxHTFsUd2pMrSqXOKxujKKIX8FGEDiXXr1ZHmVyQopXTypGmqDS++/LRERkRhdKGdM1h8oAvT11SEOcOYj5nBvn1vlvHjl8qzz77tW7V+dtX61asfLaryJVwEt/CisuIWJH955oXrjp+BY+GW1RiK5MqB9FwNgKAcDZXrx15ZjzlyisRlcxfClzxEmjdrCo07VEZCcz972hapoNgVwkhz+6B7JccbLv99YQiQHn0OpAcVfom3IFMJw7j9tSG3Q964pXIjaPPXXwtyQD9PVcISSLDJyXskKytbEW/3HrfgrVP+895w2X9gv4ppfP6NBORDc62Gt/YIZQsZ0LcbXLELbLfe0DsZRHLpQ3CUczkQbyubtvuDqZPnyyefvwIuzpWN67bjjMwhKinmDbJ5VjN4nLmDOPt5SyqU5lD54r0PJDfvNMTizTDaOGXc2Ck404uVIpTcruCk8qqCjYp6PfKAZEEB+vTFewFKWNGQbyCwSdYj8Ob8V7+eBgJZ/cF1VN4Z2hczeAWS0Lal9H/2Yb/Chn4KAbVWdWa958/D4giMv0PDw6TV1Vdh+XW+hGF+4ZdfQPAgDmWShug3CGd6It0YcCaMnwMSy5dPh/9bTmZllx09efIYxrnUcMmIz4yt37dvvwc7+0Cd3TpfA5i75ehRjL2DgjKCsEEAhjKz4trnKiOjP/8ac+N58sADQ0AMITJuwmSkpGjV/XjgGmIQnWbbrl3U+vcRLw6CA6MpxMS1Is9cmzjnOpuyzvXe5GM9M65b3noITqHcUAFD0JCoSCCSVkoolKiXUtqAWF6PHTkWiHVA9MfAzgFd5N0P4DcQKmvhQ3C+wP33nIARbSF33dEJoLDJy8+/3Rt5Vztfugt5x9ZcdOAOEREpW8asXPmLJO75CUYLt0ybvBj1JDB10GNdIJsIx0HFxgukr92YLOlp++EFUyj9+2PIAmvYz2uwg0UJkozcQOXnDihvOfDT//TpIYrzQCkoxCCE5eGaZmKczVH8va5T8V9r+uJvrPnpfM5+//aDfWC0OSm9n3xA3FjY4VWKZ6D9JHgqmZMnYHYQ3VT/+/qp1T6ffvyVVIiuir4cbUP7jFXQlMBn1I9odJoyeRmaVSAZ+5dIXr7b9shfX0w+Hh+PGaKLDxeNeOKwSlrSqq7d+nPIDUYvkBBU1oXdIGly1Y3RIlgj3C+OgfRjx3PUfPaiqT9ht4nTaBSGN5CSe1LSQBwaaOQY5qO7CYfc9cRgsWGZ0idPYPoXyCU4i1ced/7nXLrAg4szSAAMAVSo23P86Hw1kk1+uGO+/rx1Qp0nr2ki+s+Tg2FSLZD+zzyKyLDlo+4BSaUdL/ksH34LDgw5br+jm/iwasgDXWXbDtguzhMIA1oZaY+w+7B0E/WYMWlRZMWkpMCmfOdJf65XgRacK8Y5nh+LbVgdZooq27YnyoKV49Ben0yDS7WeYz93tj50/nv2pslPE6cqb5i77+2jnBt+mPQjSgqgx/R5JCAPpl3z0WCPLwsAyArq0wMV1PqE5vbA00u7cmPenpNEzPtcATGka9sEtWli3yeHFVP0NBHolFOmTsW0cYiERoSodfwfvf8NhnjcdiXQ7uAyzBDvx2krlLl67IR34AfolrU7Nm1aDC/n4PgXen9uDP1KDtjns90rr7ypKhNfvQpQhg0JYEs3CDPJNTI01CjOMk9mS4gjXLJPYkuyu26WEFeYJCfthb1cryGDm4RS6IxZ1oN+846HB4sbyuBHjw9WfGzy1mcoRnjK8PBTb0qtuOulbp0uElf3Nhk3bYmy23EVi5YPbK45VBLLvR8UIDDmlwUbfc3aN0h83M0SX+dGqV3nNjlVAI8Xf1k6H5OHSIdWLeD8gbE9JlaysdQ5EECwqhbYJBHwGQcLJISe9L+3J6J4ZemSNZB0KSq6gR3PNNtqP0RIFTCVzR6ufPXbtm2k/A8ef+Qf5ZvFHKgaKKd0VxeF+KOVGkZVyEicMH7sZPlp8RgYTPJl9oy1ZyGd1E4xz6CmWsntqfvlq+HfIG4enCKxHo79/dqftTjVUYv9dsA0J2eqXn8EkoHiziIVrMCPrdtVfpq+GPqDC/yHETe2QXnh2TekXjwML7gPDkSuIRjzDuBGvQqlRmxraVynkyJk+szB/0YB/8rGN0tSchbyN8EQEXfFc8t7j3Fyyi0PvPSMikAEqm4PMKAGD1wiM2QI4oL8VkaqzRt3IY5DTp7IsqTR/T4fMA8mY5cyZ+Z61NAh3054Q9KSjkpU+o52KtFF/JQa8aiE3RdW2OHEqVO2U6cL5Ir6tfEEFcUMFgNFM4/gQISdwhQop2vZ8HbXtVEifvOGjX7igA3bmsyv5FWH7xxDeRume8kqimPVI/wgDQBSp0EnQEajQ3nWQImids2ATkKGPPQWLgJSETVU7/hjvabALYSbh90WgSt0ZDAUCVezqkkh1s8ut3YbYEnNHALBizXvNqygoRJHLuf6AQbeq+A/T508E4qbFC0Vy8N0cEb6IUQJ1EuByQoPvPVhd21QgnRu0xSEVCAPPPjUhJNYswicBMXUxZ3vN1DS+WL5352KaVIRmMsNT9oys8cdA6HFwvoGT5Tly9edldoq4s3LpN37ZPbMOVDkCqVSzZpqbj0laQ9eG6Tr6nAkQEnBTQYJ/ObNqqOhwUhnXDhDAlE2LwwdAAgPHQhorVTxftmClUXA14jWaTWgtWjncxhcpc21d3DaDXXDXDyyKUaMKk+vHM0JEJEuT/8y13eehhIKAr3v6UcVhxuJp2KA4CkFPYXs1lAurI8k5u+/n6gIBSJAZ+T/Ne1hfjp4sYsIYI186B6+YN5K8exY9wOcXfYfrVlvGJenF8vgPDca0ueJwFeorGPR8uWte1/ZNK1OvVYhCQkdbMnJ+2Too70gWn1y+oSfos+Tj88ZiWXE4XL0wEFpff3VgK0Nq26WQ/SdO+2wvz4hIdjo4L6OHUqUIiwuXwHRzJCRITSQzJlxigGfD0oIRDpDWlqGOquND3BlpFcgP6+8+847Kk5JPw4YlGwYotgiQiUcs4rKGFNEkCaFF5snzFQ3d/a9Fd2DA77ykZgO3q2eBcoy8QPnQ/u1LvTZVy+roXCTBh3hkXRV9T4JVw7PW7ksG8wy41hM/da/RgRnIZ5ig3TIT3NgFqnf6+++u7dxQruCgf0fX7P1l62RkdVssjFpguxLny1vPPc0Cj+7/wxUUyOCy5e2bt+tDDd8V6c2fdJtcjA9Q4FbSQdY4sgNJlBU52G4U7ESe+JAr2remzN3v+CcOodcCmDgDp71gedgImybguhoKuKos0lsPat3lBM6nvISQD6UB5xuUAoW88VNApwjzk2uIi8/1Bd9BhZlhJj+WRekxD/qSrfPApi3HVhU6oIhh/4CH330OYZ3AalmpB4lAgPbQ2cQrpjlzF5v7NWbdmi2rMAKqrJVMDG0dYdcf213e0L9trf99J/X1lRLS80+FlPvwxPV4uK4/46uQeCXkFDBh2lVAP4uiI3DH3z6YeGdcc321qzTevSXwyfV7nR3K3vK3p8kPXW1bF2xWCo4KwMc4WqyZAFs7EYDZ0ZUYniQyzTwCTovNvz3yPefD4eIIqHoYs10ZDBHkhB82GaMfeoTd/Zirsz67ABkhcKuz/6SwTTGzHSpM/KwR9D8GyAqHZOxAwdHHCSxZQunqbz4Y0PGNlgLzZCKiy64P/Y9d3crihN8wRzDoY+wX7/7oSGW14E2KD0Hb5KSUoBMm5SNLgvbBOb8aQOw9C2EHwM5kT0dW0Dkz58HJQ9nbMIudSNryM51y7HaZ63s2b9UWnVtIX97+jWpF3O1/ZaY+MfTV8xJrZCxOz0zJn4M9yQ6FtOgJvNUnZXH5xm1Yt2ae9+68z57SsoROABkyhnvUcEWNGgEFApQqNKCQX3zl62RrOMYTxNQpEab6Vb8XMVcEVh/AoEeJ9TFbR6YVOCbXiVWj0DW/fyzimd+iGRroPtWLoCHxVB4HHgXKAVXeM8Z97v7dJOx46cjXqDv1UQHQEHp3L55DgB6Bu8heqHkUelSxIb02sKHb9SoUsDNjcgcQAA5DFdWciHXu0JOYSdrPKUYCCJIUzemdEA/4YISDHshaJgTA2MwaELctGEz5ufryq3db5VxX01GlnbZDWJo1DAuoFv4kU7km1CANYGTpyxBdmAyOLPWqF1Jrr66hUo/8sM3xfuhXfYdPCIdr+4pN3W4U6LKhkmNBo3vvaJlk3vff+tf3hOxDevCNCL2t9//+N6PP/jO3rR1HdmwfoSEwkZsfMvdoKsZUxcC0YgJQHHooZYwm1rgrClTU6d5TMBSqHG4dgIOk/SVK8TMVocOHYAEn+y17GiG7coUVTMt01GRc2OOnh8KIBICAGMMa9Cj83+/9qh8OXKChIH7dV1AACjPgbInTH0FBJejcomr2071p/sy1gAFtO5hoAbCbNb+Ljl6MFvSYXZmx5G8d6HUjbsJBiNY2pCSeZLjCn2nZefaxSQLdbAmBpWacHTdSE6dr20uc1b8AuQDzWivakVxEAEOSM0uCpMOXNq1cMESuanLdSoTVaZfSlHsk33MM6U3kHiAD67sOXzgNFb7LMN75pUv3W/vLHWqV5T0jKUq/3T4/bVve5vsHJMonbq0s98QEoJNOlH3WbPnH7ED0NMmfQ9lCh6yEiFzF62RydNXyqwfF6p+UhWmPGB1/6mbePZvScO5tH0ZchAUyIqTqqnPWUXaWbmgQezjGyfEnfWqpAcEavqeZTJy1HvgAHxwCAj12LNk1+5JckXDRjoJ5gJYPjmkdp32Mnn+Cpn383YpG9teTh3IUhxG2YIeFGPyPNm7d6Y0aVpJ8j1ZasOitz94SvbAz8DmAsRQv/MF1qc95uHJ8Vded+35okpBAUoF8vH5I9m9OxmINNLhvMnUS4VoItt/8KEXknUatp+ZPHGZHD1yQsWrif15UlB3ehB/P26it1xh1mElG8uERy11hJ64mz7iP2GlhqdAi28qYKR0s+qEFTxno0FCSnyqohCNXExE468AoFyAYRz8WpVHazDSrWJMKVegWvjDSh8sUYKcYHNwEJyBK/WE9fFhtQxEaajTIx3bXy1pe1eqEhlTp0IcVIz5pqQukA/+MwrHGHlm6PNom0MquCIlt4xbDmxFdwDgmzQsbdaM0arUorKAcMg8HOHYocuLMqGg4T446Jq60WqfNGrdUrYsWVssCv35jHfQ5B+mYZKqr3TucmPRAk0HjFAeDJMZFLEiH/6XFFSXanlH6ymlnROyfPkqOGxCt+rVuz17BdiMYFU8cuoQNmE8oxB/6OjxDAKWfuIYcykFgiJd6RlU1MgHFDt+Si+uKKFOaHtgitRSPcYHUmwwPERgPtpbgJWqaPT69ZuUaFdKLKNbKs6GNoLPGomIyDeIMLnakZ7pcrE6+Bt47JBDiEAu2xrW7UZsIwZDjwq6G7BeU095BjN7j2KsjcVWQDP3ocrDNdfbsZ9naTx0MDkQkVTW9p88I/NWb0d76IuDCoLohnRpriLrYZ9GOR9gBIxfKms0t/qJo0jBtMRzo42wVdSpX0dWYBtWEhK9b/Sch8pa/TB/hYPAI/3cDzvqLUzLW5anrlkeRgGY7UAXR2cRSJYCzZ6qBiePn0QFc1EBv/WLhaChBsEWRbNYsSyEhzF0sD83nF4UEfmEot0+zN61ad9G5bl37z5FAMzflFEUHxc142qp2+Lm2UAM8twXI0crpBPxoXDaCMEy4q/nzUek4KGfH8iUDkAEjxD80XrPneaQEpXDqls25KxgCEGf567ZgOSasLienrt1sJ/lYQ28c8KSSCInQVJS6l7eXxcTWaWjDIG2AddrEh1n706ePGliFJ0NDgzM1TCPBOU/iF6GIiJT1yQ6DeM87LVH4snAVDiDrgk1UEz5sYJuUCAVsXMFK9WxKB7GNMk0rCAPEoAJdHlmuooVy+lH6GcZCGwelBgMBAAD9slTZzUdiisrWBVnoZ6PP9BXQgFUzlcT+ZgbkSG3dEQ5zEwjSmWCH3Y47Ad1AB8jvS5bP2NVrZ8wMemsZ0WEWNzBOtKJMgwu1H1uaqG4yCjCunPRqbAvAkvFH8/++qBcHXSL1HAWbeC4XDEBOPPUScw+gqgMU1gZQ3W7ZC4e/pysJ4V0fxmKAVFX5pULk7AOdD3XXYgS9eh4seaaFMd+AM4EpESSVimCFdHByagj+LBzBRUraqHni8u0BIgGkQFUcI66axnS/WrEQ5+GQOErAuIFL5cmkAhUe38lEXWEgT2uwy/zR3ugexDRXG59wSFIMjAdkcUhLwmTZaxatUYGwp/w14KCIbBfrCs5R6KDB47AEBYF2LugrOqZQwVZesS4sFaNRZN6tTJHLjibrhRVsbIsBGceVuWMIseIHUbxgExDsMcrEe+E+ZXv2ECtL7D4s5EbGUlnDlN28HsIabxTnA+kG95WpaLu5Armr8pgBVQMnk0+QBcQkHHouFSJaSWVqjWR2NodgEaDQBPPmpap2S2w9rCe4RdOUarDYKxAYCwdWA+18RFvKe55FL3VcfSvn/uBfC602L4zSSpVMbYRazyAzMKMzJ9B4UNfBn79E1YKxmjr3tSDsmP7frVGQCnoiKlay0kosjgBQjHPxlEUUmSbs0KyiqZLtxbISthVwwJiXyGfYgdijKIRnbwCHp0nFVJNzfHKNIhije9cYdD//Q1jkToYkJp7IiOAJCVmqeThdeBpIK4COpQxLmaoUO1KicDcgQNKJ/eKhWM/2onuB4lZSiB94IqEFEAr8zXvzFk/Ca6ldsWy1kNfK80ebVVtViAF7NF+O7ra6IplIPJzz050AU+0Usguk1IEBIrDC0XzMAidOgdtFwyq1rR/lYksL3m5EMXAggafen/BP8GIUn2UvxAHhhZsm1m8yCXODExTLB0Ij/TggmTQIRiMKhV+WO0AwHVcfR/81LyjJEto1U2qVmsPRRe7RfrrRgCZL1kUR7pOyWfmuZEkgVqVVBqf4UB5lHbnDoG0jMZVwNhJStWrWpWAVxUZz4RzZUcEm8PE5b0JrPdBGHns8GA2QZXuhqrvxtrjDz7E0t8i8yIqAwoMDqYAcy56D44nErXS5H+KxvM+GosdWA0KeY2wAOiK0pskKFMRjZIgAeDodFYRrhFi0jOmNbZ5zkafgUNnhcpXY2bwsBq5GKCQ4BXHoSwCPThYxwfBNdZEEJyC94xJTR0xwEROWEEVwtgtFguBHLXiiXvAi/XgduW0dfAgTNUcE9KaejMbpRgWy0/fWPGir7WiSHAq24BfvCoSQIT4zOOZkoPFjgymIhTfLLg0wRCLqUBIqF2qVaoMgiKo0D+T2cHZatoz0HZVBFU6piMKaUcojloVBW90MEnN2TwPjuWDQhkTeyM8W6nb69gkZ+oEiqxRFz0ENDnpHPhbPM/Ac+uVSVVSXAMD3SZrKsb2pwSy1RJstJewLh+Nb3iAM9VQUBELRuElZG7tak3O1nJ02WA8wLMQMMjJhR8SlHiHS5erskS/m8zENB+WlKHJ+ELOsP+oBhgCYJroilRW2OfgIxzgAIZzUSzfqe+98+IyBAcIDp8BACDPT8FWoF2GYlUWhGVp8+VSa6vULU1drDBnOq0Ao+uEg6fS/kEEXK2r3qkfu7MypzALlBEB3ODvWHhmf2/EtzmrlPixFqT6KSonHMD6JQXfF8BaVzZKrxM7ig/uFA2nkV5N/BjKV/eBvsoKsBII/oK4UdcThppQIB9as7JTeHJB+dzrDkSuIygJxDoHl+PnSRMLZz7hERzTEiXo0sCoqCy85zNjozBKM9vLUcNf/tJP5aAkHqTBhQQFc39E4kjraTqtMuD4uwwak7izCIN6C7F7DQsuBDXwrA5/mcFjXIojZm4a5C+v6KQIwN9KmjXJaS44JLCo7VuTlEEhulJAeSlKWMKFmao9GwElRC72yCBIP9y6bTGkED4JnvIjVvlsgNLl772DAKvLCZR2Ntj5JPDU3AWeWN/6K3RW366fa7iiS/MnVnCFISoCJlbClggzDEh4m2Dww3t21zwMTohwhWh/enarNOBw3UMhvxkAU7Pb5olkMlVsaFhkJDk7HPZ0igVq3XRCUOu3yPMgBhNYCRbE+AxWkW0qZY3P8XsIx3MYW57IhGkYhHBDp04oWac3cc3ZlMOzabAVsMXeM47/sD4vfm2XCuVD5ejhdVKjTHn1yssJECCdRKq1bxCork6xpKZc69l6XSyy/8aQDfNT6wT9zzWcdG3ZViOGtdRDXPSRNsx+ElH79h4tYkBTBmFhPQh/nYdWIg2RMD7xpspAXpxCP3UK1sAIdrfwh6iGfc+lo/ZdqVWvCqQFMsIwatnqnbJi7S45fhzAwc6JTmSiCACmUVYKg1+VaZFdPgiBpqKqAqgsgwP7tD355P0gEsw64U/1OVCqDGJ1LNCGn8DcnKe2hOJ3lheWy1+LYxDGJDS/MJCztAna+la9Uj/M07wxZ76wXquIlh+A2nJ3vkvGs0uXW25S7R7z7Sj4A2ejbg7ZlahUrmKJyWysqznMS+4kqj2NkBI44lCYW7tyu1UawuYt2yC7j+YCt1EgbkiUCi7nyer7ahL2ts5dro/kPq7fffMpctfDmp3Je2TVml2yKTFVcadWVIh0jXhTsEGWuS/pzN2s7h/SU3MAPGBIqYoiS4qMZ2pb1BI48BzRL+gxyJo8og8A4PcKwV1i4J7dqk8qYfctPqMkvPnWTqpaLi6UvMBAOJKQDZeTIX9atFqmL9kmE+dvFY+rnJzBrOLXn/5HlfPeW29JAbbocB6u3TDuiUeGlB///QQ49Z+SLz75TIl6N7Th+wYPFM8Jl6zdkIxnBdKseQIoySCfHKP3sGMdSUGmr+E9r/XZi7lrghyToBD5K5aukPaYZ6+Cb7ccPnhcpbOOoKnUmO7D5HE2D/FJcR4/O44un1zF0nXQPBwAPtqAemqRyTjWmjBlaYNJwTI5PwEVksruuQIYgnXh/IgNc81ffvom+mx8CRuLMpBBsaDgW+yJlpCK8fAyFxa/hYtWSWgkNojARw1CwPFffPwx9h6MAIwxkIYrd/U6MdLqiiuw7Ssc0KrhwzYn6reqs7jQ/WWZfdtvyseS5Uef+pusWrBRxn49AgqfW26+/XapV68+1nSnoKIezK07pVGj+tAew1A6Zqz8WryqHBqigl9s89mqVZukE3a/yvfkyL60QmmHRt1w440ybtQEf1OIEM2FzJ8zbCQAlZ8CAAFqEG2A60963lNwXH1fXEppYrDBCeVyBGst3Zx8wQPld1AM/xxlOPDZFegZ4NAFcxeor1TpxRv6GZtNomBfDldFBQvWnqZeBi6uyMrOlWUr10E3iwZiXVKmbCXJwj4DY0eMkzBXdThxxkrNmFAZN/4jqV62qnJMPVG7wQfR6cmpqrOrsHfXXmxedFvVOo2fg8hxYg/JYRXTE6udcWNz/CF/kRXLV8si7N1WCBPStW06SAI+qrdu3Q4pADVf37YpugL4klNcaZOIqhhqSJJU11kn8R7DiH/+61F581+joWViKEWNmvoB4qnGqdagUUA4P+9l5UqdoUaavuavAsM5yKF4XPSMRVzPN2ZCTYlJdF3Ka0X1+9T2db4soXRBl2lKJgFweFYI5FOicD7PtIkEzcHkPffcg2lwL1zV90uWI08Nw5YsXqU4lHE19DTSWRdFsOymALO5cxZiTqMcbCTRknkqU0Z9PhF9e1lsrVoOH1ZoKt+NeVla1Gsip2s12uu94sbvs5H+jE+2V9yf/APz0loOLpps385J29f40CcdXzsWW/8p1Dfke5+9T/m0nc23p+6Rhx95GbM8SbJ1yw4YWdzSb8C9shxet+2va6mQTOo2DWc+VESUGAXSSfX9+t2GTYBGSubBY1Kpeg2pVrMGNgnK8Gu/BBVSo1FsdJGhgQTCjEsMVKWC31lrcHYiFZtECecNAlIprCBAO9iKnKVD0YX/3l+3UpWFuvm5XDljICe/rVDpTKEYtnGYxdUzHPkcSIbXMXwizmSjLhxqs448AW6sJ5mDgfBMh+m5YuWaMvyTEYAdJpsw4VShXB254sbaMhF6WjgcZE/Wargo2+f7vuL+lFFI6a+JykL9FCE+8AgFyRJstyTv8hlSvHE8tlH/WPFl/GizvV4ubde1eVi+07TpLfLNN9/KkCGDrUlVJQ1l84XSmqEfzJu7VG7uAi9XdA2LF66Vuwf0AsF0kEmjscQahZj+/NxILlbMJd0ogsQIRXE8RypAPO32lzNYSccKD1NGx07XKdv5ti07xYldv3VHB/MtLs7CkknkPycm78U3+H7ABhRuGTHpA7n1uusxQe2UE7EN5uTXar4mx24fVSUjObUkhJusSkS8ecmzSrw/eRSvJ2I1cOfajQbi8pbO3e/oPROrU/OwYiTz2BmpXAn7zPmVFQKUjVUijiILXJsLSqYmlbhzpjSK740P/sDbDbCmkcEHxQRyjkWoEBUJrZYizc/tAeWMrwlSzeUU4fqez88OxdPp90zNfpWcboNSpQK4y4aK0JpXcrCi0cTQzwJlBOIYp00Sc0m7fpHWqlXFohTAZuO6jfL8v56F7M+TWT8tADzCoejp9rEkMgXApgLzc2GIHVm2jPLLi65USXpc11kyazW8Hx3K3MoZyQd0zF//DdT21+NKH1QPisEIj8P9+DtvvYwdMMLgaeqQxJT9AFmgstaslKgHoB1wvMst1EMYOzwzv/7iOwDfJvcOHGCZhGAe6A2h/XPvO3K/lgSspjmYu/Wa98UDkRFASPF3vAvHHDw9Wal32KEkKfOoP5pJq8/+pdQkQBVMufpe2wPIOzxMHDILy0dajKv5aVEl0nUG6vee/rDHQ1/aiAUVgm3d7r+3Gzgdm69ila7pHkx0RaR+EcCNkhYsWqHqjk0PpVGrekA6lbWkbyun775gpDPvQG1NSRdwDs91eCuUiZLIMmEyYewEv0GmeMIi0c1CyNAAxcI5a1CgV55/YTC+HBGl1F1ayGnYYxxzHIarEH3gCjDOLbJpq6qyugCqQgSBS3dJw/8G4DoO4+mjOFLwEPvGfSibts+S5JS52JJsnvw48zMMNgN+aYG0jO3vhoqQr5+p53zHcmCb4JW6LioXHjtwM2O7iTydJ37hqxcGRxPOTq5fh+/zeY7BwOXD/r2JSKmHdypvJDEwpATlNXcEK1c2WhYsWATO5zavX8Flzv0245c2EDqlDlGHU45gGc43nW9pDXce+p5ho19o+QysIA9DuabyfMflTPjaujw4+HYAxSfzZs6HDuCRewffx9dIp5E1Z/oMfEw4TDYfOAExB65RwFQxIAScMvTL6fLABxPhKojRguI2P2cWAd0g3TTP3KtipFO7K6VShA9kcwa1yZaWCVjECcSWRGQsW6+m0VIkIBFExkybKwNf+0g2UMLSv18RANqBNCRoHxDvAoMYWFBrG3j/ABC1DR4xx9DdlZd9KeuVA1layoki2FlhxrS8p+Fs+7bd4oZTy97EfRJZMULK2EI9khNJhb3UwUCm1AmxLv25/777io9bcmWkpUNJ1rbgX8toNjYF5tKkX3bMlZPZ2nbPNAPvH6wARN3AC78AW5hT5qzaCiDC/Vm5QNMPPkyemoiNECPKS0iFinLfe1Q9NEKYR8kBTQRS3CofIqSELsnPzfQX0EETConsXIFLsBamZuLrV5Vl9OqVkqPGiCxLp3nmM2x5gu5qz6atKgsiu3pMGX+f75Rp0+fIzIWf4x67icxeAcT65fk5CuT8yYnMU5KRlAEqCJepP30v+BJYrypHt18U4s/dsnNUwDwul7E981idJm9Wqlz3xfmz58uQBwZK8r40qVerporC4ZsR3SYNz+TqXLgph2Oq1A3ngPHfjZF+QwcpdBQAPXTH5NLnz/72mjz075flhZFTkegM9o/B/jMkLlgOj27fIfWbN8NEf1XoFuRIg0xDx/o89N0RYq9QVVwYhXw4FHvOoE5UGOnmxBhMpa74HIGgPwJXtye/mAr8+WTsY73xxOSpYzMew2MffCW2kGisklkj1/S4UV4dO0PC4MHatmk9mbdyi5SrzM+huWQptjJVmxhCxHfr1lUV8uknn2MMHi71YusqUivAAjsbLKUOaHGG24ukhL9u2dnZqLoLq3tmQcMrI01q1PIdc3rW6tqU/te0qvQpkWJrevIrs376FtIaBhcoHseOYt0atWMqcwrKZ2fLBi2aBy6AYpWcOlttfjRnBvZ2h/l38KBB6O/gv0oRCU3/45f+IaHoC13YUCEUCpkLyBjz/Csyb9RIGf7M85hnd8mL32GTY8Wxgaawt33snY8ktHwsFnPAuxffoXvy6wlKASXSdSDKeU2EMgWDXf45YRkmMspjr9kK8sQ3U+ArajiRcfXxw6Ll4oisLjEVK8juZatkxGMvyMnkFLFHRsnCXRniqlpVcg4elq+f/Tvmv9FRYIBCEY8OHtIOZh1MmOzaOQ/tKcSqV+yFi5yDGZ4EYA6W+8uWJDXe54ea29zSSE7VatSvamrqYdb6YoKfni4mqSJeeGe58+sl3OA8feqoPP7oI1hoGAd3aqAd1jkltllCEfDQBIg8vEFj3dLttuuA/Ey59aYB0u9+fE0Koykv9pofj++70AtHuSQBqdS63XCeICC4whT/SjQOfOGvElIWUgB2gh7Xt5AWNWOxv61d3vtunOSHwM8P4vebJ/8mA997TW2Z9nq/W2DcYNCINiSgke6VR9/+QkJimsnwh4eJNzxCnvr4LQnHnjZ/69cVugD3unDICx9+hd2yK2MXLpeMefE1oIQjFT3pxJzJ5cyfz9T4HY3q1acXXKaj1Td73nv3Y7n+5gQZ+Tm3cT0DJtgCbgc8EF8Nf9FGMgcJwYshLp9zBLIG35z7/PMvlFKXsXdj1nK7s2Kns5cNsQoXFIiWSwrY0vSeE6vmje3Yuju+GdMP9md88O+qhkC8tsApA46lBDW889/fdOs1aJRT4ut3AWJtMvj+vhj6eCXrVDZW6UKkYThHi5rxiCUgaeqEFVQF2vWj68dI9wcHSDicRdUXI4EcN4CfdfSMjHnzXWUxpM/aI2+/oiY/Xhl0O5DI4M9EXdvl+Q8xOVWxnpSPLIfddXfO0gAAGupJREFUqx5TAHdhyDT49ZeVvzt9N0iIHvgrVINm/f5TzyE/fLmGLxAckCRG0pm5cUo9Olzc99ADkGJ2+ezDrzHTDT/3bQuBVA+WNq8E0olpjQYdXyOeRK6IAeJi3c9bsaOlT74fMVKeeuVBefDVz26qdCBxgSr4In8uGfEkTiwEOBzfoF3lPDf2pB06TJo1icESIwACiDkf4snVXW+7Fo0PwV5y2O3RliX39u8veVjqzK1OZ03DF6agLBgvIIN4QFg1l0Cn5CaAGl3bSq5u20Y2rNskO1bgc11u7icP9BKCAGwhhkxDXn5adUHh3tPy4gND1UJPD6TJs8O/lTJY9OGA2/V3/3hHCrEXPR1RyHFh6HrYhsiYahJdvpKkYkNHDj+5KohUpZw6iiFedw0aoT7pN2igGs/PBCEfO3gQw8dFqHOhzP5xBVL5VazzIJ77AnKLuM8/G4FuwykHMjZthqLXEq3SBf1/IZ7lZtasf9vW6WNn3NljkAwd9qCaur3yitqADnRoAM3K5YyvRBqeE4EE4O13tFfLp7kZgQ3bi909oJ8CPJE+aQLshQhKbOJMPAYCeml/8/VYWb9hXHUA8SYd3xTAiDT0xWdU3pyYcdPzFhNN5LTwApt88upboOLAVDM1bY63SVjUWtRuAv7COQxl3uzSrEHFRfx8MMGgYcNUVzB1+iw5k3kCe+QtggQrlDlzlkPCoeP3BzaBhGLleLaHXdzq9TuUn9yXX3wlHXu2leHTFjbD1yW3mbQXey4GxovNBBWH9dGb2ap11/L79iTJwMeekKug3Ya5CgEwTZpW5NMEaZQZAi80zCc33owNBLxh0qDuzZLvBefDosex64njx+WnWbOVksT6aREIBZKEc55Q9N4vHVRUSAgSysmCXHnmtZfxvZsysmTBItm6hMoxVT1a7IFQP3UpiQIuIzLZ7aizpUxKtCLCIxGQQPCAz/s/OBRE7ZHMo8exxdtcfCRwKVJCM0fes2Zg+Ibxi3WVrRXxLIJ5HTpyTJLxpYvRX4HbYSHdk7xuaIgz5GtLFS76kni5LOFIbL27w3dvHV+v7lXSZ8AAcYWXlbatagOYug+0Ij64QJo0a9aIkKuuagZguKROzA3gmDNy34MY24Mj2SVMngQNG8A1gGYeVBIDQYt/3hchPfDyrCvmY5USBqkmrTkzoXkXuNb6gcrDQoBEOnel6j9kEFeMyYHDB2X+rEUwuGBKG3AIg2ifii1LWG/qC6w9EaDOFo5nOfxC1tLNKbJm2VpJ2rFd3h/+mtzyyNONK+1L2sn3lxouG+JReQe4vrB2fGsbl+Je3bkTqDRXBvfqjinWgPhkhcntZuKh6B4ArBETJVdeeQW6ArvUqt1ePBjn9x06WPWp5P4Jo8dAHEJ5Q60NARjRrxEVQP6lAobpg5HPnbVJBCzTlK/qr/por/S65y6JqlhevZ86cbpkHz2Nna2gpALVUEllxrR1jM6+Dj+aeHjLO+arJCHODHN+WiIV4pvKSI4isNtHavIaORKXUJeOMyrCJf7oUi4xEyY/Flv36nJ7d6+r26AtxjR52HMFu17AnXfuvNnY8o2KHulah5IQr95ALJev6JJ2ba8CsRRKXBy+wIRp3Htg0uU2HhSHM6AknTpxsgjwBvFMT7+1yxmK1RkI4fwdg0E866OkATyIhwy9Hx9QQC8NAv36q5FizxHsozMN4p4iXfA1qiXKds/0uprFEc/nJAi6a+Xmn5E+vbpic5J8qV//DtgxHJKSuFRyaiYklD2QuEvFvcSfywIpgAPM4Mnr2Lmnay801xQYJ6j8LIUP2OmsfCAMM2H+ihJ0vLaKTwKCig0DxbnNlyu33XYDlGanxNXtCAHpk653dMfnuOAerbgFEy2jxhX7IAJXmqqAvtiYTfWD4pzLZwah1jqYuNYzORwFoq7+vHFXhGxegxju6N1DDWGdGBVwNu7jdz6TsmXLS9KuGag/jMCI8+O0ZYSQyprpjU8hGquJCHEY+Kv89NBNeG050hPI37QtWXr3fFRq1qkhq+dPuw1lUoRccrgssvFU7fgWM+bOcSVj2DFz9qfw0+M6rSzJyeKyXD1kIWJ46CaeXW/DuVrjLyNTpi5WkVJTF8s/33hOZv8wVb7/egQpA1yEjZHw2e4BA+9TeRKkTMf16HqoR4Tx0M+DERx8z3h8pg9q+fow9+o9EGbcmFlGlSqVZMDgu7FKKFxZGk+dPoNvu4+SctGhcI+GmRmIpi1j+tSlrERRu4ORzrzZJh6aeCEdMYHl9tCf0SctmtSRCNgl9qcdko07t03LrFvXv62ISnnRP+fCQ6kyhPVuQaPGnTrnQBtP2QYTJHat+mn6RgV6UjhDUYN54wdEMQQQsGw/owMI5EpqwD3uaIN8YMIFOqrWbA7LGKaH4Fd2V997AH/G08OgsaNGa45h/uDS4GBVDKlcmbJ4NkgvSgOpYa2vaQM5/4YbOkD/iAWSYFzCXLstNEI+e/dzfGMmQhau+EziqlbDcxc0+dUgUM4isH9H+4syZ/OKK6lFRO8fgbDtXii1BYUQ+X07q66hIZxX7Pj0S+L25T2xAneaJbuLurxkxHOf1C+eeiz984+/l6S9y7Ck96SsXrkBCzKAFELVjwQrIA3iDTCsGj/FvpGsGgAibdolSOXKlZGXW/YcPiG3tO0Nq1mBxDe/Qlq2bAUVGOIYiOCGRNu3b5fNMOJo5wpwD/pfzt9b87WOBkzZqkwSpKmUASeIIAQb7Nx9T0/Mh+s1gHzFPEaNniz5WS4pDD0ih3YvUeMX8vYP4xcr86xqu4KBzowIN8E8Ntug8DkJwEwNq7ZjOHhrtw4gKq9ccWVPSFA3dtdu6R2+bGGz6LRkPQ9uMizl+ZIRfzo3e2Czph2/e/KlQfIw9mvzwD17/pz1mnP9lSmG9KIG4sIvDUwlyHlEkAlEAgFEIHDBxy3dWqsJF7pC7z98Sm66YZDk4XOmdkzh9rt/kHIFJ/K5uICB+e3HlPHCeYtRlJYitLdooqCGjnh+LqNY5uaFXJ8eAvfx6zq1k6oQ54gEgxTXuHNjKGwcga7ro48+wUYS1eW0bb8cSVkDVGMVMI5dew7Iji2pqLTmctMOotuKdD43iOe14XjMQRUbsZAoCuG11Kv39aiGBy5rd2Gr2TyUsbjQm3BVnUoZifuZ/mKCBcylTw5u731Pi5YTt+9OwVhzMbTWHHxE+GcgimaQQNaXgnhDCMaoQt2hR88uiovdWHwwd83P8tJD7+PDftidEqXecEtnfB++Llb+0pUJdQDHcs97OFnp7oPVIrJBTBTdJCoGzXn6TEyQEGia9UFTD8d34z7/z1eYR8BMIbYX9zpgWNkxB6ngKoVffob8x2krMetGZwzoFsBqoPXIA3EuBPFG+rCrM4H6jAft7HXnrZJ12ibNm1+H6eBQSUtcvQ6TUNeiHK3MmAQXeLbW7wKT6GhUMvbPnnHilhvvsS1aP1Vqw9ly7aqNwq9WEElsaBFQUXlD1dZCTENNJQzHG3FrkG5No5AJU25eAT75dVc3hWwCin39W59/Jd9+go8c5RXA3s4PlGD1SEx1uQnr06LKAWGY6oVAAN7PhpUPVqSCwjylqB2Cd8z0aTOAP7pmRKpp1fzQHNm1azZQDe5WXYcdHwDk/rOrQVxcaKqRpZwrObLwI089PUf72S4DA14rXcKajs9wcF1jN8xp0FZfozbOMAW163iVfLV02b0V05PGMW1pg4F5adMJNsN/7tbY2m9n7D8gqXtWY7uR47J6xU6llBDhPAzyi4ZaQaUUibuSlD1/XCJfIdt/T/FMiaICCKAQny/r1etGEAB5j4DiKILfqsqXFk27YMgHr1V8280LQsC+EJooQQAUz2qWhoAGIokABxYckiT0DhR2GfRQT3n9hWEgH7p7MHA61yuZxz34js52iH69dZh6hR8zK8d70oEhfN4bAuA1AxmBZRrFUT/V6cy1OTMfWjd79GiLkYtTYmt2hHcPTLh71khhfKNqZS5iXv6iEH+gRoNK1fbvOtqw4TVyEkufvx79ARwmAFg3d5XS3MTlQ6bhStT7KVk1WEEBzfL38YY7CAS+snKBaryJ54eEkgwAhgrkJkzD0ToYUcYlt3TpCNQQUXSe1FO6CgnsozEhm5mVKzvwtecD+49LQW4eth6pILXjYrBdSrRUiAwDL5HDClEHVRPc0eePbXHIDxPmo/8Hz/NdUJ1UXfw/ZqdP80xJLtSTOZIZFMH707PNhrD5vBh8GN+PIbqDn8k+JVfjW7btW+DbtqhDSvomyarXsHqVvXsPmbIu9OyfF7zQ6DpejQOJx47HNPi23yPDBg//YIRMx6RDXEws+p848pEKpjHqhuLV/5ycw66X94bqzDsSiJUDFLebl/70PBmCUo8AOCpz5AC4+MNjdimIAHGg9RM4N93aRq31A3lAROdL9SgMC1sngCQMD+uMydUebOvqppcMfO2S8a2cHdv3oJ/Xs/c0MUXgM6I6WIae/idF0gv3GMVp5PrfKclHBKN9iqj9DVdIZ/v8REyWwfhEpTLwU9uV4RF3kFmxOlFWbzqIOtoh8qPAbFyhpCjUX9KFnwzsLzyFP+aRuLhqFVKSDjZIaCN5Obky9JFHMW7FfrWtGgKj4Dk0iAgyB6unrpGehbK95yrcNJqIN1OV/mIv6EQdQxMHNHc4PyrYoE50+uDSLE4FU0LQuqjWl2NiiGLadCNAjy4H+Rjxrerk51K+NNxpKlQM8f56m3esi7IdcMLJ0ugixJuI/rPqAsgdCCyXn25btHQD3L3KyagvvlZSIy39ZzlTq8k7lTJSnvcnK9XJ38JSpVGRKV6y4hrfu3XbEmwi7JIvh38Ga51XVq/bhYWCBKJ/Hpv9GBtBoJE7/feW9qv3jKMOOEBQQeJB8RYs+orimXyDq06NHUHHYz8O9ocljGUrhw5c0wLnDIVRCGZWJ1am8J5EodOB1BCXhxoV8tpffyLXHIwbjGw9h+5vh79+amjJ/EHmypXKn3fJSCfP+w8QKomORqItO5Kw7qK8jMAwkgz0j7eexufMQ3wel/c/rMfFhItGPAujRhnpKjPqX2+9pBr27XffYrzrlTVwi9ZKGblNW9YIpJKEkgIq8iJBKDGIawLQTJkSYOaaZQYHKyL4jrxFiWMOkz/PStSiHiQCdY8zr3ko5dDcWwphnVXdcCYR8mAwZ5bPOvJgUPmiLBMccNVSq3Ygq8274nCwIBuJDAx0XLtsRHeTXeiUrz75RH1NI6qKSx6+t7+ciGnQ9//N2ZKNY7uP16zX79/97v1q8vhZIfQl6zcA7lPZWdLl5g6IkA+NFBIAhwns86yB3K25hXSIeejlm6Bh06vWI1e1auQHKQHEwHOAXrVIVy/84l1fm18CkHF4vtBAZFqDQbJ5pogY+fG56WLp2KnSgegwISc/YzuZvDPYIh1eP17sC9Du2quhO9BHj7AAcao2mDaZnPWZ0oBd0Mp1WyXfUU7tU5B3+oTUrFtNflm7XE7UajigUkby6OKpSnd34dD4lXzRoLAnn38pa+qYn5zuEPiaAflc6XLT9dcA8Rj2cGEkghVRvCdCtDj0yfHMbNm9ay987hwy9ptvpD/cuMIwxOLmSQ0b1oDJVItMK9Cs+VmvmTdDEeJZPDka4Vzx1Ev8WBFvkG442sThmXnzPf3mGdh1/DhzkYRElAPinLJkySLpAX8Eex60Tnxz5orm8YhFQxL8EyiZSggGHouXboanbxkZ+dlwBcea8VVl88plkl07YXCF9KTvSkhaqkeXDfEsFWP7xz965OEPv/l8hPpK5OChD0LTLsDmCc1B5Zq6g4GugAfqXgH7fiH6Z2rkE7/B5gmwX3KLEAzEZdjDj2LBJdymgJFwrDu7IiEOUNeWueD8Smo94yjxepGIV8gIkgLqGfpf5T6FlTqrVm3TG5lDsk2ZMlnOnMbwFh8H8GJfvb8891elL1DpbHlFPagcRDyIAcFaf+ZJO8QSGMJybJEyeviXWBeATZfrVJHdq5djzXv9YRUzUr4sqY2lfXZZEc+P2VdITDw5bfly218GDEOrnHBDGqw6xHbXNlaUznVoDIaTCJHlEO1n4LWzacMG2bMD68OA770pG2TclOnyxkvvw0qHVTcggH739sPMHHfMgNLnOSNtWrcCcZjFjpoDgwFAwJKDVfdyEYhXyABCVKDugMD1fNRhtm/fKaeyqITik4gg7G9GfCVOfIWas4k14iPA8VPkmoSuam8hflZu2LCHAAOvREeFSAKIl7TEnGngZrDZw7Aa9mds0OCS7z7/DCuRQyWmSXVZv2ienK7d6NGK6cmfqYiX4cffosuQkz+LzNj4h8unJX56KPOo7do2XcWDRZX3DIIPHpUcTDRcc3VTTHqg3yVlw5/Mjo8BEakj8DFChy9SGrWogm1XfvRl1ml4HXzqu1VI2/23I6ePYw+dXvhkB753BywSifc9cD80chAAJjE8WPRwVavGmBHD58fAd9ZAxCuuoo7hRzwyUIizxiOCGaxiXnE1CJN9Lpduc+eKOYuWYhSDxRqQ7pyt+/KLL8TJ5d9Q7zhka9S6riyYOg5DrabPopCoCum7X+l8W398CXK7qsftd/SQKtFVcO2Rdu3w6XFMtbJ+mzbsxDdr0V1AinyJTYvQwUmvQbfK8LffkpO1GzwGpH9qre+lXl92xLNC/JqhzeZ9NiRl85MtW3SChSxXWrZuLQktWgDdPqlXp66s37wJy6ciZNu2rbJhxUoJwyKFTVtnSzTm2k/GNLy94v6kmUCV7VStBnXgbDkdBND0DNbQ3Xjz3XIo6bDkoc9kP2l3hki/gYPQ32LeDMgpzM2CFa6a1IMiRIXSjfE6A6+JmKLAYZ+fg9V7ID6AdD9nA+FbsHx5Xwa+8FCjDvKnouiRrb/8ImsXrlB9vAfllyEBjHlLOrW5FugKkcyY+v+O3p/yD+aLLzy+VT498fnD2Kfm6mY3qe6ABDXwgUFKoQ1jnqh7IQb4h7DsaubU6eKCRFuDZdyx5atCkWswNDoj+euiel+mi98E8aZux2PiXwlP3fLPa9t2k9OHj4kXHqgDBg+CTxm+G5uXJ2NGjUVUr0RUiZI9G5dJTlyTZ+1u7w8VDlq+RogY5NWjNes3R486tmJGYkIe+s1hTz4nG5duh/9dJroNIAocSDViCMTp4SOYwevRSnnourE/L92ci7ie+bHVfsQHc7pS1izjrfmLN+PrmLGyZu1GWb9sEeqijUAhQHbVBpVl3fwfUTS+/x7bYIrNZ9sAm8B4SLw9KKEoHIuN74GEd5VJ296/Vevb5NihQ2rY9ujTjwPh1PJ9MuLrbyUPXjz4jKXs2btW8mOb/9Pu8XwXDIuiTC/x4jdFPOt2rGb91yqk73op49gR6QwCyMYMWPOWrWXLlq1wwY6SCZP+K20aNgeXN+he8UDyjPO1BwTgOB5btyUsF6ftdg/yTbyLH+pLTseXrYc8JXv3pEkWNvPrN2iY3IlvrRVgSFkIpZD9Kj/4YyaL/FqGkhKmPMPtVsS7wrA6dc4m+f67r7D7Bz6SVKmafDH8LencoQ2s/i7uObMb6tg40FsyhlfjEaVkVd1fyPHYesMrpCUNmwQH1Of+8i8pyMsWJ0YAOTk5as1d17tvkC9ffwM7VSW8Ai5/1dTttzj/5ohnpfFV47dh7HkuC5/6vLlzd3jn5EmZypGyaj6WFsMWjk0WvozOSII2WLpwEF9K5qQKg8fp/Pcbg+7pP/LLiXLPkGHo77FnbrtmsCbC/w8cT8SXFAzHUyIY5Bsz7Z4MOI6mZaoFDfx4QMa+rXIqttF8dOgrYJlcXCG9xmq1UVRJGZ/jGaTgNxXSEu+n1Lrh5j5yAH6KFdA1LVqMFUNxLbdixnhghQPJm86R/LI9/l0Qz776OJQ+u89WBuOqJhCF93GHJkjUZTaXcxz32bvUFh2vFd8kf8OKbVc07SxDn3haTp8+Kd1uJOI5+aJFvRL3QQUZxPOxNjJBUaPmhjB36UZ40EbJyG++lur1qsqmJQt9OdUbVI06lHxURbjIHyw5GwYLQC5I7dayaTv7nqrdaAfockClA8mbgZCSKfQiyzpXMm2gPtfby/QcjfGJfygCunbcHNfgw4oZMVtKyy2/Vp2q0ZWwjj5MDmXsk4pVqqNQCnX4AmHeoGgO35+JFeF8RG7HP6/UL+fksau3nDh9SrleTZowWrAy+IlKh1IuCenMHIrrFzyjvDHHYhu9C4T/Ahidt5tg/MsZdCsvZ46/klcfNLD8vuSNlxvpLJYIDoVm/9PMH5XbFHZZKKoNEW09il74L4rsCrin9u/AjB138/5x8hSlfdfFZgcY1i0KTncp90R25QOExe+LdNb5d0f8pQDqfGkrwus0M6bB/KiyEcrbhopcUuJeNQbnxAeJojThTC40bP+sGhcsQmPHVrOW8V9pMvsfjFs6aPwPNsBUid0JRvV/vYu7V6ADs8Pku2PbPj354zfcGI43aUo6K85H/GXYgYJr+NAXY/vVstwidF6lg0mXZflSSeX+3s/+NIgn4Lg/1l+fegKbFGOsXZAvkVFl/f08CAFc/2uBM4Rqx0uM8SNgSFq9Wi+f/vb7z6ED2J9Deq0G/FpGf4D3fyrEE95cXBkZjq26R4yAKzTnwiNU3853RtwHK3Z8x6AlAkACaxydG3dt+QUUAzNsrXo6wp/o93fR6n8veHG6hsi97oZrZNbMxRISGSI/YdbPgRnCyHCHNE2ohylefH0ajAtjmdLkqchxmMel3RjyY2/eAtm1+6h4MG4nIURVLIup0Ma4phvPnyf8qRBfZX/iFtgHlr2XuPm6WTPaSkF+vvKIdcNIlI2tTn7evk8RBr1k1fANCKd11hhuCkA0sAqKG25OToz9Oa5/4OF7pMIDj3BK9HcZX/9epPXrHd/vVZPLVM7RGvEty6fv2NCwQXvJhSMIkUrkFsIRlE6WXAZFK15hoX8qFEM+Jxc/ol+nzZ1TybT9Y1W7+MD1+zN+lqxajf4anZ7y3mWq4v9ENn8qjidEYQzZdLx248U703Z0OnnmtMzFxMro0ZMwa+f1pu2Ell/gkgKsP/NBjPvgccslT25MGtkwgRTfuJ7PG+q1Nbm6ubzx3FP2SKyA5Zo4iInZ/xPYuoyV+NNxPGFDJs+MqfcAllVVdjsd40LA3hUO7Mm4YLg1aeI8eTynhooPp7rfaobsguvzG0T8Py2bkg5thBnNAAAAAElFTkSuQmCC')
LICENSE_KEY = "eRyQJbMFadW9NjlLbonpNalnV7HPlLwQZ5SJI06UI3k9RWlfdUmHVfsCbL3lB6lqcNiaIus1IKkJxDpcYd2AVeuqcf2MVNJ8RiCWIa6qMNTKc2yvOkTmMJ5WMKTsAO1fNfCRwLi0TKGilrjyZfWt5izcZUUVRFlGcPGPxTvDeIWw1hlZbgnPRpWJZjXJJgzcaTW79yu6IpjvonxmLWCRJrOjYLWp1XlMRpm5lKyZcc3dQPisOTi8JVNZQlVah0JwTJSlIXsDIxkw5IhObMWyVRMhYiXzNn06IwjsoqisQJ0ehFVITtU0F8LwTD1iYbiBLFCEJfDybc2417w6YvWZ5x5yIgjno0iiIViAwTiMQv39Vlz5dqGg96t9ZVXBJpJlRDC5In6zItjfQWyVOVTzQy0EIoibwlieRMGYFJ0rZRUrldzPcc3HVDlDZfClId6tIMjTEqw1LHz0ISw6LnzmIvwoM7jdQqiHLkCMJCEhYoXnRylcRPX8hbwha9XtJdlZccyZI166IqjZEzwmLtzqI4wsLqz3I8wrM9jbUJicLjCBJNFfb2W1FNpVbbEfFKkHZxHtJWl4cn3NMEimORiVJfrEY5XtBnpId3GF9jzoa6G1tph4YMWx16y7QXG0dPtMY2Wtl3sgLBmONZvTbVSmIbstI6kjlhQ8QtWzRdkJccmSVWzdcpyqIM61IOjngn5WLvjFQB2qLXjXI3zmOXCG4XxoOnTvAPiWfcQ9=s=N2557ebc9fd1e19890386096eefc382eeb0240112c5cdb0528933da16a8db3d21534920b7e6b0158d6c6416da9c7b9d0b28b62bb06b34533d1348928bc379915c6eebe6a7c528dd6b008bec7357e2087db89156d861d012acffcefffcfedc0be8113013a5dbafb175dc25b6cbc159ef5312296478bd6b26317f594aa98b32cf28b521a07a3e41f784c1592a5355cadcc507299aced0edf6dae2178eccb4dc174a55ceb5e295ac79765ab235f3d8040db9e8d4feaa4230d6b6e8966d384ccceb41d3824d5d70d51ac93dcd200a1e8fe9e5b7347acf21f4581d9e1e1283af4fadc678cfbc23aea61af58601a77335adaa276652709408c335c56196cf121693979b2a5d2cf59192a5f5b366db58890b3599c1e544da8a7a4fea4c77bbe03180cfe1f779ab59c61de53ac3b4d2f85ffd883b7e0dbbf6b828abd2f08c4d9faac68369a5d2ea0293fb82f652d4e99581d45b647cce31559fbdc6023d84fd001ae3291dbedf1baab581c1b704fcdbab598d95b9ad0f6b392fc87255aa868ebea62daf4c9013a986c951609f2173c2231f66869e8b0b21a4c53cfe80968fb324b99f074e0fe62f79355964d5771e6c2c146eeb50c145aab7efb8606a96fc2a2cb3e6621b6c167e413149d099100dd5289b09670557d8a653b705a366655e4ea96aaafd5788a7163e28defb63c78fc340182353904cbf318e29d26c8052256451ff79b36b"
sg.set_options( )

if getattr(sys, 'frozen', False):
    BASE_DIR = sys._MEIPASS
else:
    BASE_DIR = os.path.dirname(os.path.abspath(__file__))

TEMP_BANNER = os.path.join(BASE_DIR, 'ghostvault.png')
NEW_MESSAGE_SOUND = os.path.join(BASE_DIR, 'message_in_dialog.mp3')
DEFAULT_AVATAR_PATH = os.path.join(BASE_DIR, 'avatar.png')
CONFIG_FILE = os.path.join(BASE_DIR, 'database_config.db')

def get_db_path():
    """Возвращает корректный путь к database_config.db в зависимости от окружения"""
    if getattr(sys, 'frozen', False):  # Если программа запущена как .exe
        base_path = sys._MEIPASS  # PyInstaller сохраняет временные файлы сюда
    else:
        base_path = os.getcwd()  # В обычном режиме используем текущую директорию

    db_path = os.path.join(base_path, "database_config.db")
    if not os.path.exists(db_path):
        db_path = os.path.join(os.getcwd(), "database_config.db")  # Проверяем в рабочей папке

    return db_path

# Встроенный Master Key
MASTER_KEY = b'Ваш ключ'

# Встроенные зашифрованные ключи
ENCRYPTED_LOGIN_KEY = b'Ваш ключ'
ENCRYPTED_MESSAGE_KEY = b'Ваш ключ'
ENCRYPTED_DB_KEY = b'Ваш ключ'

# Декодируем ключи
cipher = Fernet(MASTER_KEY)
LOGIN_ENCRYPTION_KEY = cipher.decrypt(ENCRYPTED_LOGIN_KEY)
MESSAGE_ENCRYPTION_KEY = cipher.decrypt(ENCRYPTED_MESSAGE_KEY)
STATIC_DB_KEY = cipher.decrypt(ENCRYPTED_DB_KEY)

fernet_login = Fernet(LOGIN_ENCRYPTION_KEY)
fernet_message = Fernet(MESSAGE_ENCRYPTION_KEY)

# Установка пользовательской темы для GhostVault
sg.LOOK_AND_FEEL_TABLE['GhostVault'] = {
    'BACKGROUND': '#1c1c1c',
    'TEXT': '#f0f0f0',
    'INPUT': '#2b2b2b',
    'TEXT_INPUT': '#f0f0f0',
    'SCROLL': '#2b2b2b',
    'BUTTON': ('#f0f0f0', '#444444'),
    'PROGRESS': ('#2b2b2b', '#444444'),
    'BORDER': 3,
    'SLIDER_DEPTH': 0,
    'PROGRESS_DEPTH': 0,
}
sg.theme('GhostVault')

# Установка PostgrePortable
def get_downloads_folder():
    """
    Получает путь к папке Downloads текущего пользователя.
    """
    return Path.home() / "Downloads"

def get_local_folder():
    """
    Получает путь к папке Local текущего пользователя.
    """
    return Path.home() / "Local"

def download_postgresql_portable():
    """
    Скачивает PostgreSQL Portable в папку Downloads и распаковывает его в папке Local.
    """
    try:
        # URL для скачивания Portable PostgreSQL
        downloads_path = get_downloads_folder()
        local_path = get_local_folder()
        zip_path = downloads_path / "postgresql-portable.zip"
        unpack_folder = local_path / "PostgreSQL_Portable"

        # Прогресс-бар для скачивания
        layout = [
            [sg.Text("Скачивание PostgreSQL Portable...")],
            [sg.ProgressBar(100, orientation='h', size=(40, 20), key='progress')],
            [sg.Cancel()]
        ]
        window = sg.Window("Скачивание", layout, finalize=True)
        progress_bar = window['progress']

        try:
            # Скачивание архива
            if not zip_path.exists():
                with requests.get(POSTGRESQL_URL, stream=True) as response:
                    total_size = int(response.headers.get('content-length', 0))
                    with open(zip_path, "wb") as file:
                        downloaded_size = 0
                        for chunk in response.iter_content(chunk_size=1024):
                            if not chunk:
                                break
                            file.write(chunk)
                            downloaded_size += len(chunk)
                            progress_bar.UpdateBar((downloaded_size / total_size) * 100)
                            event, _ = window.read(timeout=10)
                            if event == 'Cancel':
                                sg.popup("Скачивание отменено.")
                                return None
                sg.popup("Скачивание завершено!", title="Успех")
        except requests.exceptions.RequestException as e:
            sg.popup_error(f"Ошибка скачивания: {e}")
        except Exception as e:
            sg.popup_error(f"Произошла ошибка: {e}")
        finally:
            # Убедитесь, что окно закрывается
            if window:
                window.close()

        # Распаковка
        if not unpack_folder.exists():
            sg.popup("Распаковка архива...", title="Распаковка")
            with zipfile.ZipFile(zip_path, "r") as zip_ref:
                zip_ref.extractall(unpack_folder)
            sg.popup("Распаковка завершена!", title="Успех")

        return unpack_folder
    except requests.exceptions.RequestException as e:
        sg.popup_error(f"Ошибка скачивания: {e}")
    except zipfile.BadZipFile:
        sg.popup_error("Ошибка: Архив повреждён или не является ZIP-файлом.")
    except Exception as e:
        sg.popup_error(f"Произошла ошибка: {e}")
    finally:
        window.close()

def configure_and_run_postgresql(portable_path):
    """
    Конфигурирует PostgreSQL Portable и запускает его.
    """
    try:
        # Путь к исполняемому файлу PostgreSQLPortable.exe
        exe_path = portable_path / "postgresql-portable-main" / "PostgreSQLPortable" / "PostgreSQLPortable.exe"

        # Проверка наличия исполняемого файла
        if not exe_path.exists():
            sg.popup_error("Файл PostgreSQLPortable.exe не найден. Проверьте структуру распакованных файлов.")
            return False

        # Запуск PostgreSQL Portable
        sg.popup("Запуск PostgreSQL Portable...", title="Запуск")
        subprocess.Popen([str(exe_path)], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        sg.popup("PostgreSQL Portable успешно запущен!", title="Успешно")
        return True

    except subprocess.CalledProcessError as e:
        sg.popup_error(f"Ошибка при настройке или запуске PostgreSQL: {e}")
        return False
    except Exception as e:
        sg.popup_error(f"Произошла ошибка: {e}")
        return False

def check_and_switch_to_online_mode():
    """
    Проверяет, использовать ли онлайн подключение, и переключает статус.
    """
    try:
        # Проверка: если есть файл конфигурации для онлайн подключения
        if os.path.exists(CONFIG_FILE):
            sg.popup("Переход на онлайн-подключение...", title="Онлайн режим")
            return True
        else:
            sg.popup_error("Онлайн конфигурация не найдена. Работайте в локальном режиме.")
            return False
    except Exception as e:
        sg.popup_error(f"Ошибка переключения в онлайн режим: {e}")
        return False

portable_path = download_postgresql_portable()
if portable_path:
    if configure_and_run_postgresql(portable_path):
        # Проверяем возможность перехода на онлайн режим
        is_online = check_and_switch_to_online_mode()
        if is_online:
            print("Программа работает в онлайн режиме.")
        else:
            print("Программа работает в локальном режиме.")

# Функции шифрования
def encrypt_data(data):
    return fernet_login.encrypt(data.encode()).decode()

def encrypt_message(data):
    try:
        return fernet_message.encrypt(data.encode()).decode()
    except Exception as e:
        print(f"[ERROR] Ошибка шифрования сообщения: {e}")
        return None

def save_new_config(dbname, user, password, host, port, config_path=CONFIG_FILE):
    """Шифрует и сохраняет данные подключения в .db файл."""
    cipher = Fernet(STATIC_DB_KEY)
    data = {
        "dbname": dbname,
        "user": user,
        "password": password,
        "host": host,
        "port": port,
    }
    encrypted_data = cipher.encrypt(json.dumps(data).encode())
    with open(config_path, "wb") as db_file:
        db_file.write(encrypted_data)

# Функции дешифрования
def decrypt_data(data):
    try:
        return fernet_login.decrypt(data.encode()).decode()
    except Exception as e:
        sg.popup(f'Ошибка дешифровки: {e}')
        return None

def decrypt_message(data):
    try:
        return fernet_message.decrypt(data.encode()).decode()
    except Exception as e:
        print(f"[ERROR] Ошибка дешифровки сообщения: {e}")
        return None

# Функции работы с базой данных
def load_encrypted_config(config_path=None):
    """Читает и расшифровывает зашифрованный .db файл конфигурации."""
    if config_path is None:
        config_path = get_db_path()

    if not os.path.exists(config_path):
        raise FileNotFoundError(f"Файл конфигурации '{config_path}' не найден.")

    cipher = Fernet(STATIC_DB_KEY)  # Используем статичный ключ для расшифровки
    with open(config_path, "rb") as db_file:
        encrypted_data = db_file.read()

    try:
        decrypted_data = cipher.decrypt(encrypted_data)
        return json.loads(decrypted_data)
    except Exception as e:
        raise ValueError(f"Ошибка расшифровки файла конфигурации: {e}")

# Функция для создания пользователя ghostvault и базы данных
def create_ghostvault_user(server_conn, host, port):
    """Создает пользователя ghostvault, базу данных и таблицы, а затем сохраняет данные подключения в .db файл."""
    layout = [
        [sg.Text("Введите пароль для пользователя ghostvault")],
        [sg.InputText(password_char='*', key="-GHOSTVAULT_PASSWORD-")],
        [sg.Button("Создать пользователя", key="-CREATE_USER-")]
    ]

    window = sg.Window("Создание пользователя ghostvault", layout)
    while True:
        event, values = window.read()
        if event == sg.WIN_CLOSED or event is None:
            break
        if event == "-CREATE_USER-":
            new_password = values.get("-GHOSTVAULT_PASSWORD-", "").strip()
            if not new_password:
                sg.popup_error("Ошибка", "Пароль не может быть пустым")
                continue

            try:
                server_conn.autocommit = True
                cursor = server_conn.cursor()

                # Создание БД и пользователя
                cursor.execute("CREATE DATABASE ghostvault")
                cursor.execute("CREATE USER ghostvault WITH PASSWORD %s", (new_password,))

                # **Даем пользователю ghostvault права на схему public**
                cursor.execute("ALTER USER ghostvault WITH SUPERUSER;")

                cursor.execute("GRANT ALL PRIVILEGES ON DATABASE ghostvault TO ghostvault")

                # Подключение к ghostvault
                conn = psycopg2.connect(
                    dbname="ghostvault",
                    user="ghostvault",
                    password=new_password,
                    host=host,
                    port=port,
                )
                conn.autocommit = True
                cur = conn.cursor()

                # Выдача прав и создание таблиц
                cur.execute("GRANT ALL ON SCHEMA public TO ghostvault")
                cur.execute("""
                    CREATE TABLE public.users (
	                    id serial4 NOT NULL,
	                    username varchar(50) NOT NULL,
	                    login text NOT NULL,
	                    "password" text NOT NULL,
	                    "key" text NOT NULL,
	                    photo bytea NULL,
	                    CONSTRAINT users_pkey PRIMARY KEY (id),
	                    CONSTRAINT users_username_key UNIQUE (username)
                    );
                """)
                cur.execute("""
                    CREATE TABLE public.dialogs (
	                    id serial4 NOT NULL,
	                    user_id int4 NULL,
	                    recipient_id int4 NULL,
	                    message text NULL,
	                    "timestamp" timestamptz DEFAULT now() NULL,
	                    CONSTRAINT dialogs_pkey PRIMARY KEY (id)
                    );
                """)
                cur.execute("""
                    CREATE TABLE IF NOT EXISTS public.dialog_history (
                        user_id INT REFERENCES public.users(id),
                        recipient_id INT REFERENCES public.users(id),
                        last_message TIMESTAMP,
                        CONSTRAINT dialog_history_pkey PRIMARY KEY (user_id, recipient_id)
                    );
                """)
                conn.commit()
                cur.close()
                conn.close()

                # **СОХРАНЕНИЕ ПАРАМЕТРОВ В database_config.db**
                save_new_config(
                    dbname="ghostvault",
                    user="ghostvault",
                    password=new_password,
                    host=host,
                    port=port
                )

                sg.popup("База данных настроена!", "Файл database_config.db успешно создан.")
                break

            except Exception as e:
                sg.popup_error("Ошибка", f"Ошибка при создании пользователя ghostvault: {e}")

    window.close()

def edit_encrypted_database():
    """Открывает окно для просмотра и редактирования зашифрованных данных в файле database_config.db"""
    try:
        # Читаем текущие данные из файла
        with open(CONFIG_FILE, "r", encoding="utf-8") as f:
            encrypted_data = f.read()
    except FileNotFoundError:
        sg.popup_error(f"Файл {CONFIG_FILE} не найден!")
        return
    except Exception as e:
        sg.popup_error(f"Ошибка чтения {CONFIG_FILE}: {e}")
        return

    # Создаем окно для редактирования
    layout = [
        [sg.Text("Текущие зашифрованные данные:")],
        [sg.Multiline(encrypted_data, size=(60, 5), disabled=True)],
        [sg.Text("Введите новые зашифрованные данные:")],
        [sg.Multiline("", size=(60, 5), key="-NEW_DATA-")],
        [sg.Button("Сохранить"), sg.Button("Отмена")]
    ]

    window = sg.Window("Редактирование зашифрованных данных", layout, modal=True)

    while True:
        event, values = window.read()

        if event in (sg.WINDOW_CLOSED, "Отмена"):
            break

        if event == "Сохранить":
            new_encrypted_data = values["-NEW_DATA-"].strip()
            if new_encrypted_data:
                try:
                    # Перезаписываем файл новыми данными
                    with open(CONFIG_FILE, "w", encoding="utf-8") as f:
                        f.write(new_encrypted_data)
                    sg.popup("Зашифрованные данные успешно обновлены!")
                except Exception as e:
                    sg.popup_error(f"Ошибка при сохранении данных: {e}")
            else:
                sg.popup_error("Новые данные не могут быть пустыми!")

            break

    window.close()

def connect_to_db():
    """Создает подключение к базе данных, используя зашифрованный .db файл конфигурации."""
    try:
        config = load_encrypted_config()  # Передаем правильный путь
        conn = psycopg2.connect(
            dbname=config['dbname'],
            user=config['user'],
            password=config['password'],
            host=config['host'],
            port=config['port'],
        )
        return conn
    except Exception as e:
        sg.popup_error("Ошибка", f"Не удалось подключиться к базе данных: {e}")
        return None

def get_active_dialogs(current_user_id):
    conn = connect_to_db()
    cur = conn.cursor()
    try:
        cur.execute('''
            SELECT DISTINCT ON (recipient_id) recipient_id AS user_id
            FROM dialog_history
            WHERE user_id = %s
            UNION
            SELECT DISTINCT ON (user_id) user_id
            FROM dialog_history
            WHERE recipient_id = %s
        ''', (current_user_id, current_user_id))

        user_ids = cur.fetchall()
        active_dialogs = []
        for user_id in user_ids:
            cur.execute('SELECT id, username FROM users WHERE id = %s', (user_id[0],))
            user_data = cur.fetchone()
            if user_data:
                active_dialogs.append(user_data)

        print(f"[DEBUG] Получены активные диалоги: {active_dialogs}")
        return active_dialogs
    except Exception as e:
        print(f'[ERROR] Ошибка получения активных диалогов: {e}')
        return []
    finally:
        cur.close()
        conn.close()

def get_users():
    conn = connect_to_db()
    cur = conn.cursor()
    try:
        cur.execute('SELECT id, login FROM users')
        users = cur.fetchall()
        decrypted_users = [(user[0], decrypt_data(user[1])) for user in users]
        return decrypted_users
    except Exception as e:
        sg.popup(f'Ошибка получения пользователей: {e}')
        return []
    finally:
        cur.close()
        conn.close()

def get_chat_history(user_id, recipient_id):
    conn = connect_to_db()
    cur = conn.cursor()
    try:
        cur.execute(
            '''
            SELECT user_id, message, timestamp
            FROM dialogs
            WHERE (user_id = %s AND recipient_id = %s) OR (user_id = %s AND recipient_id = %s)
            ORDER BY timestamp
            ''',
            (user_id, recipient_id, recipient_id, user_id)
        )
        rows = cur.fetchall()
        history = []
        for row in rows:
            decrypted_message = decrypt_message(row[1])
            if decrypted_message is not None:
                history.append((row[0], decrypted_message, row[2]))
            else:
                print(f"[ERROR] Ошибка дешифровки сообщения: {row[1]}")
        return history
    except Exception as e:
        print(f'[ERROR] Ошибка получения истории сообщений: {e}')
        return []
    finally:
        cur.close()
        conn.close()

def find_user(search):
    conn = connect_to_db()
    cur = conn.cursor()
    try:
        # Разделяем введённый текст на username и id, если формат соответствует USERNAME#ID
        if "#" in search:
            username, user_id = search.split("#", 1)
            username = username.strip()
            user_id = user_id.strip()
            cur.execute('SELECT id, username FROM users WHERE username = %s AND id::text = %s', (username, user_id))
        else:
            # Ищем либо по username, либо по id, если текст не содержит "#"
            cur.execute('SELECT id, username FROM users WHERE username ILIKE %s OR id::text = %s',
                        (f'%{search}%', search))

        results = cur.fetchall()
        if not results:
            sg.popup('Пользователь не найден.')
        else:
            sg.popup(f'Найдено пользователей: {len(results)}')
        return results
    except Exception as e:
        sg.popup(f'Ошибка поиска: {e}')
        return []
    finally:
        cur.close()
        conn.close()

def send_message(user_id, recipient_id, message):
    timestamp_utc = datetime.now(timezone.utc)
    conn = connect_to_db()
    cur = conn.cursor()
    try:
        encrypted_message = fernet_message.encrypt(message.encode()).decode()
        print(f"[DEBUG] Отправляемое сообщение: {message}")
        print(f"[DEBUG] Шифрованное сообщение: {encrypted_message}")

        cur.execute(
            '''
            INSERT INTO dialogs (user_id, recipient_id, message, timestamp)
            VALUES (%s, %s, %s, %s)
            ''',
            (user_id, recipient_id, encrypted_message, timestamp_utc)
        )
        cur.execute(
            '''
            INSERT INTO dialog_history (user_id, recipient_id, last_message)
            VALUES (%s, %s, %s)
            ON CONFLICT (user_id, recipient_id) DO UPDATE SET last_message = EXCLUDED.last_message
            ''',
            (user_id, recipient_id, timestamp_utc)
        )
        conn.commit()
    except Exception as e:
        sg.popup(f'Ошибка при отправке сообщения: {e}')
    finally:
        cur.close()
        conn.close()

def update_existing_messages():
    """Обновляет все существующие сообщения в базе, чтобы они были зашифрованы текущим ключом."""
    conn = connect_to_db()
    cur = conn.cursor()
    try:
        cur.execute("SELECT id, message FROM dialogs")
        messages = cur.fetchall()
        for message_id, old_message in messages:
            try:
                # Пытаемся расшифровать старое сообщение текущим ключом
                decrypted_message = decrypt_message(old_message)
                if decrypted_message:
                    # Перешифровываем сообщение текущим ключом
                    new_encrypted_message = encrypt_message(decrypted_message)
                    cur.execute(
                        "UPDATE dialogs SET message = %s WHERE id = %s",
                        (new_encrypted_message, message_id)
                    )
                    print(f"[DEBUG] Обновлено сообщение ID {message_id}")
            except Exception as e:
                print(f"[ERROR] Ошибка обновления сообщения ID {message_id}: {e}")
        conn.commit()
    except Exception as e:
        sg.popup(f'Ошибка обновления сообщений: {e}')
    finally:
        cur.close()
        conn.close()

def create_sql_dialog(current_user_id, recipient_id, refresh_user_buttons):
    """
    Создает диалог в базе данных, если его ещё нет, и обновляет кнопки диалогов.
    :param current_user_id: ID текущего пользователя.
    :param recipient_id: ID найденного пользователя.
    :param refresh_user_buttons: Функция для обновления кнопок диалогов.
    """
    conn = connect_to_db()
    cur = conn.cursor()
    try:
        # Проверяем, существует ли уже диалог
        cur.execute(
            '''
            SELECT COUNT(*)
            FROM dialogs
            WHERE (user_id = %s AND recipient_id = %s) OR (user_id = %s AND recipient_id = %s)
            ''',
            (current_user_id, recipient_id, recipient_id, current_user_id)
        )
        if cur.fetchone()[0] == 0:
            # Диалог не существует, создаем новый
            raw_message = "Диалог начат"
            encrypted_message = encrypt_message(raw_message)
            if not encrypted_message:
                print("[ERROR] Не удалось зашифровать сообщение для создания диалога.")
                return

            cur.execute(
                '''
                INSERT INTO dialogs (user_id, recipient_id, message, timestamp)
                VALUES (%s, %s, %s, %s)
                ''',
                (current_user_id, recipient_id, encrypted_message, datetime.now())
            )
            cur.execute(
                '''
                INSERT INTO dialog_history (user_id, recipient_id, last_message)
                VALUES (%s, %s, %s)
                ON CONFLICT (user_id, recipient_id) DO UPDATE SET last_message = EXCLUDED.last_message
                ''',
                (current_user_id, recipient_id, datetime.now())
            )
            conn.commit()
            print(f"[INFO] Диалог успешно создан: {current_user_id} -> {recipient_id}")
        else:
            print('[INFO] Диалог уже существует.')

        # Обновляем кнопки диалогов
        refresh_user_buttons()

    except Exception as e:
        print(f'[ERROR] Ошибка создания диалога: {e}')
    finally:
        cur.close()
        conn.close()

# Вспомогательные функции
def generate_key():
    return ''.join(random.choices('0123456789', k=6))

def update_user_photo(user_id, file_path):
    """Обновляет фото пользователя в базе данных."""
    try:
        if not file_path.lower().endswith(('.png', '.jpg', '.jpeg')):
            raise ValueError("Файл должен быть изображением (.png, .jpg, .jpeg)")

        # Открытие изображения и изменение размера
        image = Image.open(file_path)
        image = image.resize((124, 124), Image.LANCZOS)

        # Сохранение изображения во временный файл
        temp_file_path = f'temp_avatar_{user_id}.png'
        image.save(temp_file_path, format='PNG')

        # Сохранение изображения в базе данных
        with open(temp_file_path, 'rb') as file:
            image_data = file.read()

        conn = connect_to_db()
        cur = conn.cursor()
        cur.execute("UPDATE users SET photo = %s WHERE id = %s", (image_data, user_id))
        conn.commit()

        # Удаление временного файла
        os.remove(temp_file_path)

        print(f"[INFO] Аватар пользователя {user_id} успешно обновлён.")
    except Exception as e:
        print(f"[ERROR] Ошибка обновления фото пользователя: {e}")
        raise

def play_sound_non_blocking(sound_path):
    """Воспроизводит звук в отдельном потоке."""
    threading.Thread(target=playsound, args=(sound_path,), daemon=True).start()

def process_avatar_image(avatar_path):
    """Обрабатывает изображение аватарки: изменяет размер до 124x124 и центрирует его."""
    target_size = (124, 124)
    try:
        with Image.open(avatar_path) as img:
            img = ImageOps.fit(img, target_size, method=Image.LANCZOS, centering=(0.5, 0.5))
            img_byte_arr = io.BytesIO()
            img.save(img_byte_arr, format='PNG')
            img_byte_arr.seek(0)
            print("Image processing successful.")
            return img_byte_arr.read()
    except Exception as e:
        print(f"[ERROR] Ошибка обработки аватарки: {e}")
        return None

def handle_avatar_selection(user_id):
    """Обрабатывает выбор аватара пользователя."""
    try:
        file_path = select_file()
        if not file_path:
            print("[INFO] Операция выбора аватара отменена.")
            return  # Прекращаем выполнение, если файл не выбран

        avatar_data = process_avatar_image(file_path)
        if avatar_data:
            update_user_photo(user_id, avatar_data)
            print("[INFO] Аватар успешно обновлён!")
        else:
            print("[ERROR] Ошибка обработки аватарки.")
    except Exception as e:
        print(f"[ERROR] Ошибка при обработке выбора аватара: {e}")

def select_file():
    """Выбор файла через tkinter с ограничением на изображения."""
    root = tk.Tk()
    root.withdraw()
    try:
        file_path = filedialog.askopenfilename(
            title="Выберите файл",
            filetypes=[("Изображения", "*.png;*.jpg;*.jpeg"), ("Все файлы", "*.*")],
        )
        if not file_path or not os.path.isfile(file_path):
            return None
        return file_path
    except Exception as e:
        print(f"[ERROR] Ошибка при выборе файла: {e}")
        return None

# Окна и их функции
def register_user(username, login, password, key, avatar_data):
    """Регистрация пользователя в базе данных."""
    conn = connect_to_db()
    cur = conn.cursor()
    try:
        cur.execute('SELECT COUNT(*) FROM users WHERE username = %s', (username,))
        if cur.fetchone()[0] > 0:
            sg.popup('Ошибка: Этот username уже занят. Пожалуйста, выберите другой.')
            return

        encrypted_login = encrypt_data(login)
        encrypted_password = encrypt_data(password)
        encrypted_key = encrypt_data(key)

        cur.execute(
            'INSERT INTO users (username, login, password, key, photo) VALUES (%s, %s, %s, %s, %s)',
            (username, encrypted_login, encrypted_password, encrypted_key, avatar_data)
        )
        conn.commit()
        sg.popup('Регистрация успешна!')
    except psycopg2.Error as e:
        sg.popup(f'Ошибка регистрации: {e}')
    finally:
        cur.close()
        conn.close()

def login_user(login, password, key, parent_window):
    conn = connect_to_db()
    cur = conn.cursor()
    try:
        cur.execute('SELECT * FROM users')
        rows = cur.fetchall()
        for row in rows:
            db_login = decrypt_data(row[2])
            db_password = decrypt_data(row[3])
            db_key = decrypt_data(row[4])

            if db_login == login and db_password == password and db_key == key:
                sg.popup(f'Авторизация успешна!')
                parent_window.close()
                dialog_window(row[0], row[1])  # Передача ID и username текущего пользователя
                return
        sg.popup('Ошибка: Неверные данные для входа')
    except Exception as e:
        sg.popup(f'Ошибка при авторизации: {e}')
    finally:
        cur.close()
        conn.close()

def main_menu():
    layout = [
        [sg.Image(filename=TEMP_BANNER if TEMP_BANNER else None), sg.Text("GhostVault", font=("impact", 80), text_color='#a8bbb7')],
        [sg.Button('Авторизация', font=("Helvetica"), pad=((280, 276), (0, 0)))],
        [sg.Text(" ")],
        [sg.Button('Регистрация', font=("Helvetica"), pad=((280, 276), (0, 0)))],
        [sg.Text(" ")],
        [sg.Button("Создать базу данных", font=('Halvetica'),pad=((250, 10), (0, 0)), key="-CONNECT-")],
        [sg.Text(" ")],
        [sg.Button("Подключиться к базе данных", font=('Halvetica'), pad=((225, 10), (0, 0)), key="-RECONNECT-")],
        [sg.Text(" ")],
        [sg.Button('Выход', font=("Helvetica"), pad=((300, 300), (0, 0)))]
    ]
    window = sg.Window('GhostVault', layout, size=(680, 480), finalize=True)
    try:
        while True:
            event, values = window.read()

            if event in (sg.WINDOW_CLOSED, 'Выход'):
                break  # Корректно завершаем цикл

            elif event == 'Регистрация':
                window.hide()
                registration_window()
                if window and not window.was_closed():  # :white_check_mark: Проверяем, не закрыто ли окно
                    window.un_hide()

            elif event == 'Авторизация':
                window.hide()
                login_window(window)
                if window and not window.was_closed():  # :white_check_mark: Проверяем перед вызовом
                    window.un_hide()

            elif event == "-CONNECT-":
                new_db_connect()

            elif event == "-RECONNECT-":
                edit_encrypted_database()

    except Exception as e:
        sg.popup_error("Произошла ошибка", str(e))

    finally:
        if window:  # :white_check_mark: Проверяем перед закрытием
            window.close()

def new_db_connect():
    layout = [
        [sg.Text("Подключение к серверу базы данных")],
        [sg.Text("Имя базы данных",pad=((1, 10), (0, 0))), sg.InputText(key="-DBNAME-")],
        [sg.Text("Пользователь",pad=((1, 33), (0, 0))), sg.InputText(key="-USER-")],
        [sg.Text("Пароль",pad=((1, 71), (0, 0))), sg.InputText(password_char='*', key="-PASSWORD-")],
        [sg.Text("Хост",pad=((1, 89), (0, 0))), sg.InputText(key="-HOST-")],
        [sg.Text("Порт",pad=((1, 88), (0, 0))), sg.InputText(key="-PORT-")],
        [sg.Button("Подключиться", pad=((180, 88), (0, 0)), key="-CONNECT-",)]
    ]

    window = sg.Window("Подключение к серверу базы данных", layout)
    while True:
        event, values = window.read()
        if event == sg.WIN_CLOSED or event is None:
            break
        if event == "-CONNECT-":
            try:
                conn = psycopg2.connect(
                    dbname=values.get("-DBNAME-", "postgres"),
                    user=values.get("-USER-", "postgres"),
                    password=values.get("-PASSWORD-", ""),
                    host=values.get("-HOST-", "localhost"),
                    port=values.get("-PORT-", "5432"),
                )
                sg.popup("Подключение установлено", "Теперь создадим пользователя ghostvault")
                window.close()
                create_ghostvault_user(conn, values.get("-HOST-"), values.get("-PORT-"))
                conn.close()
                break
            except Exception as e:
                sg.popup_error("Ошибка", f"Ошибка подключения: {e}")
    window.close()

def login_window(parent_window):

    inner_layout = [
        [sg.Text('Логин', size=(6, 1), font=("Helvetica",14)), sg.Input(key='-LOGIN-')],
        [sg.Text('Пароль', size=(6, 1), font=("Helvetica",14)), sg.Input(password_char='*', key='-PASSWORD-')],
        [sg.Text('Ключ', size=(6, 1), font=("Helvetica",14)), sg.Input(key='-KEY-')],
        [sg.Text('')],
        [sg.Button('Войти', size=(60, 1), font=("Helvetica",10))]
    ]

    # Внешний макет с отступами
    layout = [
        [sg.Text('', size=(75, 1)),sg.Button('❌', size=(2, 1))],  # Верхний отступ
        [sg.Text('', size=(5, 1)), sg.Column(inner_layout), sg.Text('', size=(5, 1))],  # Отступы по бокам
        [sg.Text('', size=(2, 1))],  # Нижний отступ
    ]

    window1 = sg.Window('Авторизация', layout)

    while True:
        event, values = window1.read()
        if event == sg.WINDOW_CLOSED or event == '❌':
            break
        elif event == 'Войти':
            connect_to_db()
            login_user(values['-LOGIN-'], values['-PASSWORD-'], values['-KEY-'], parent_window)
            break

    window1.close()

def registration_window():
    """Окно регистрации."""
    generated_key = generate_key()

    # Основной макет
    inner_layout = [
        [sg.Text('Username', size=(10, 1), font=("Helvetica",14)), sg.Input(key='-USERNAME-')],
        [sg.Text('Логин', size=(10, 1), font=("Helvetica",14)), sg.Input(key='-LOGIN-')],
        [sg.Text('Пароль', size=(10, 1), font=("Helvetica",14)), sg.Input(password_char='*', key='-PASSWORD-')],
        [sg.Text('Ключ', size=(10, 1), font=("Helvetica",14)), sg.Input(default_text=generated_key, disabled=True,key='-KEY-', size=(39, 1),text_color="blue"),
         sg.Button('🔒')],
        [sg.Text('Аватарка:', size=(10, 1), font=("Helvetica",14)), sg.Input(key='-AVATAR-', size=(36, 1)),
         sg.FileBrowse(file_types=(("Images", "*.*"),))],
        [sg.Text('')],
        [sg.Button('Зарегистрироваться', size=(61, 1), font=("Helvetica",10))]
    ]

    # Внешний макет с отступами
    layout = [
        [sg.Text('', size=(75, 1)), sg.Button('❌', size=(2, 1))],  # Верхний отступ
        [sg.Text('', size=(5, 1)), sg.Column(inner_layout), sg.Text('', size=(5, 1))],  # Отступы по бокам
        [sg.Text('', size=(2, 1))],  # Нижний отступ
    ]
    window = sg.Window('Регистрация', layout, finalize=True)

    while True:
        event, values = window.read()
        if event == sg.WINDOW_CLOSED or event == '❌':
            break
        elif event == '🔒':
            new_key = generate_key()
            window['-KEY-'].update(new_key)
        elif event == 'Зарегистрироваться':
            connect_to_db()
            avatar_path = values['-AVATAR-'] or DEFAULT_AVATAR_PATH  # Используем дефолтную аватарку, если пользователь не выбрал
            avatar_data = process_avatar_image(avatar_path)  # Преобразуем изображение
            if not avatar_data:
                sg.popup("Ошибка обработки аватарки. Пожалуйста, выберите другое изображение.")
                continue

            register_user(
                username=values['-USERNAME-'],
                login=values['-LOGIN-'],
                password=values['-PASSWORD-'],
                key=values['-KEY-'],
                avatar_data=avatar_data
            )
            break
        elif event == '-AVATAR-':
            avatar_path = values['-AVATAR-']
            if avatar_path:
                avatar_preview = process_avatar_image(avatar_path)
                if avatar_preview:
                    with open("temp_avatar_preview.png", "wb") as temp_preview:
                        temp_preview.write(avatar_preview)
                    window['-AVATAR_PREVIEW-'].update(filename="temp_avatar_preview.png")

    window.close()

def on_connect_button_click():
    """Открывает окно ввода данных подключения."""
    layout = [
        [sg.Text("Имя базы данных"), sg.InputText(key="-DBNAME-")],
        [sg.Text("Пользователь"), sg.InputText(key="-USER-")],
        [sg.Text("Пароль"), sg.InputText(password_char='*', key="-PASSWORD-")],
        [sg.Text("Хост"), sg.InputText(key="-HOST-")],
        [sg.Text("Порт"), sg.InputText(key="-PORT-")],
        [sg.Button("Подключиться", key="-CONFIRM-")]
    ]

    window = sg.Window("Введите данные для подключения", layout)

    while True:
        event, values = window.read()
        if event == sg.WIN_CLOSED:
            break
        if event == "-CONFIRM-":
            try:
                conn = connect_to_db(
                    values["-DBNAME-"],
                    values["-USER-"],
                    values["-PASSWORD-"],
                    values["-HOST-"],
                    values["-PORT-"],
                )
                if conn:
                    sg.popup("Успех", "Подключение к базе данных установлено!\nСохраняю данные в конфигурацию...")
                    save_new_config(
                        values["-DBNAME-"],
                        values["-USER-"],
                        values["-PASSWORD-"],
                        values["-HOST-"],
                        values["-PORT-"]
                    )
                    conn.close()
                    break
            except Exception as e:
                sg.popup_error("Ошибка", f"Не удалось подключиться к базе данных: {e}")

    window.close()

def dialog_window(current_user_id, username):
    """Главное окно с диалогами."""
    selected_user = None
    chat_history = None
    last_checked_message = None
    temp_files = []  # Список временных файлов аватарок
    message_queue = Queue()  # Очередь для новых сообщений

    def create_user_buttons(users):
        """Создаёт кнопки для пользователей."""
        return [[sg.Button(f'{user[1]}#{user[0]}', size=(30, 1), key=f'USER_{user[0]}')] for user in users]

    def convert_utc_to_local(utc_time, user_timezone="Europe/Moscow"):
        """Конвертирует время из UTC в локальное без смещения часового пояса."""
        if isinstance(utc_time, str):
            utc_time = datetime.strptime(utc_time, "%Y-%m-%d %H:%M:%S.%f%z")  # Преобразуем строку в datetime
        elif not isinstance(utc_time, datetime):
            raise ValueError("Неверный формат времени")

        utc_time = utc_time.replace(tzinfo=pytz.utc)  # Устанавливаем UTC таймзону
        local_time = utc_time.astimezone(pytz.timezone(user_timezone))  # Конвертируем в локальное время
        return local_time.strftime("%Y-%m-%d %H:%M:%S")  # Форматируем без смещения

    def format_timestamp(timestamp):
        """Форматирует временную метку, убирая +03:00 и приводя к локальному времени."""
        if isinstance(timestamp, datetime):
            utc_time = timestamp.replace(tzinfo=pytz.utc)  # Устанавливаем UTC-зону
        else:
            utc_time = datetime.strptime(timestamp, "%Y-%m-%d %H:%M:%S.%f%z")  # Парсим строку времени

        local_time = utc_time.astimezone(pytz.timezone("Europe/Moscow"))  # Переводим в локальное время
        return local_time.strftime("%Y-%m-%d %H:%M:%S")  # Возвращаем строку без +03:00

    def get_user_photo(user_id):
        """Получает фото пользователя из базы данных или возвращает дефолтное изображение."""
        conn = connect_to_db()
        cur = conn.cursor()
        try:
            cur.execute('SELECT photo FROM users WHERE id = %s', (user_id,))
            result = cur.fetchone()
            if result and result[0]:
                temp_photo_path = f'user_{user_id}_photo.png'
                with open(temp_photo_path, 'wb') as file:
                    file.write(result[0])
                temp_files.append(temp_photo_path)  # Добавляем в список временных файлов
                return temp_photo_path
            else:
                return DEFAULT_AVATAR_PATH
        except Exception as e:
            print(f"[ERROR] Ошибка получения фото пользователя: {e}")
            return DEFAULT_AVATAR_PATH
        finally:
            cur.close()
            conn.close()

    def delete_temp_files():
        """Удаляет все временные файлы аватарок."""
        for temp_file in temp_files:
            try:
                if os.path.exists(temp_file):
                    os.remove(temp_file)
                    print(f"[INFO] Временный файл {temp_file} удалён.")
            except Exception as e:
                print(f"[ERROR] Не удалось удалить временный файл {temp_file}: {e}")
        temp_files.clear()

    def refresh_chat():
        """Обновляет чат при наличии новых сообщений."""
        nonlocal chat_history, last_checked_message
        if not message_queue.empty():
            new_chat_history = message_queue.get()
            if new_chat_history != chat_history:
                chat_history = new_chat_history
                chat_text = '\n'.join(
                    [
                        f"[{format_timestamp(msg[2])}] {selected_user[1] if msg[0] == selected_user[0] else 'Вы'}: {msg[1]}"
                        for msg in chat_history]
                )
                visible_window['-CHAT-'].update(chat_text)

                # Проверяем последнее сообщение и воспроизводим звук только для входящих сообщений
                if chat_history:
                    last_message = chat_history[-1]
                    if last_message[0] != current_user_id and last_message != last_checked_message:
                        play_sound_non_blocking(NEW_MESSAGE_SOUND)
                        last_checked_message = last_message


    def fetch_chat_updates():
        """Фоновая задача для проверки новых сообщений."""
        nonlocal selected_user
        while True:
            if selected_user:
                new_chat_history = get_chat_history(current_user_id, selected_user[0])
                if new_chat_history != chat_history:
                    message_queue.put(new_chat_history)
            time.sleep(2)  # Проверка новых сообщений каждые 2 секунды

    def select_dialog_window(current_user_id):
        """Открывает окно выбора диалога."""

        def create_window_with_buttons(active_dialogs):
            """Создаёт новое окно выбора диалога с кнопками."""
            dialog_buttons = create_user_buttons(active_dialogs)
            layout = [
                [sg.Text('Выберите диалог или найдите пользователя')],
                [sg.Input(key='-SEARCH-', size=(30, 1)), sg.Button('Поиск')],
                [sg.Column(dialog_buttons, scrollable=True, size=(300, 400))],
                [sg.Button('Закрыть')]
            ]
            return sg.Window('Выбор диалога', layout, modal=True, finalize=True)

        active_dialogs = get_active_dialogs(current_user_id)
        dialog_window = create_window_with_buttons(active_dialogs)

        selected_user_local = None
        while True:
            event, values = dialog_window.read()
            if event == sg.WINDOW_CLOSED or event == 'Закрыть':
                break
            elif event.startswith('USER_'):
                selected_user_id = int(event.split('_')[1])
                selected_user_local = next((user for user in active_dialogs if user[0] == selected_user_id), None)
                break
            elif event == 'Поиск':
                search_query = values['-SEARCH-']
                if search_query:
                    try:
                        username, user_id = search_query.split('#', 1)
                        user_id = int(user_id.strip())
                        username = username.strip()

                        create_sql_dialog(current_user_id, user_id, lambda: None)
                        active_dialogs = get_active_dialogs(current_user_id)

                        dialog_window.close()
                        dialog_window = create_window_with_buttons(active_dialogs)
                    except ValueError:
                        sg.popup('Ошибка: Проверьте формат USERNAME#ID.')

        dialog_window.close()
        return selected_user_local

    def refresh_visible_window(active_dialogs, selected_user=None, chat_text=None):
        """Создает новое окно с обновленным интерфейсом."""
        left_column = [
            [sg.Image(filename=get_user_photo(current_user_id), size=(124, 124), key='-USER_AVATAR-')],
            [sg.Button('Выбрать диалог', size=(15, 1),)],
            [sg.Button('Информация о себе', size=(15, 1),)],
        ]

        right_column = [
            [sg.Text(f'Диалог с: {selected_user[1]}#{selected_user[0]}' if selected_user else "Диалог с: Не выбран",
                     size=(30, 1), font=('Helvetica', 16), key='-DIALOG_HEADER-')],
            [sg.Multiline(default_text=chat_text or "", size=(55, 15), key='-CHAT-', disabled=True,
                          autoscroll=True, font=('Helvetica', 16))],
            [sg.Input(key='-MESSAGE-', font=("Helvetica", 16)),
             sg.Button('Отправить', font=("Helvetica", 14), size=(10, 1))],
        ]

        layout = [
            [sg.Column(left_column), sg.VSeperator(), sg.Column(right_column)],
            [sg.Text(datetime.now().strftime('%H:%M:%S'), key='-CURRENT_TIME-', justification='right', expand_x=True)]
        ]

        return sg.Window('GhostVault - Диалоги', layout, finalize=True)

    threading.Thread(target=fetch_chat_updates, daemon=True).start()

    def update_avatar_window(current_user_id, username):
        """Окно информации о себе с возможностью обновления аватара."""
        info_text = f'Информация о: {username}#{current_user_id}'

        layout = [
            [sg.Text(info_text, font=("Helvetica", 14), justification='center', expand_x=True)],
            [
                sg.Image(filename=get_user_photo(current_user_id), size=(124, 124), key='-CURRENT_AVATAR-'),
                sg.Column([
                    [sg.Button('Скопировать', size=(15, 1))],
                    [sg.Button('Обновить аватарку', size=(15, 1))],
                    [sg.Button('Закрыть', size=(15, 1))]
                ])
            ]
        ]

        avatar_window = sg.Window('Информация о себе', layout, modal=True, finalize=True)

        while True:
            avatar_event, _ = avatar_window.read()
            if avatar_event in (sg.WINDOW_CLOSED, 'Закрыть'):
                break
            elif avatar_event == 'Скопировать':
                pyperclip.copy(f'{username}#{current_user_id}')
                sg.popup('ID скопирован в буфер обмена!')
            elif avatar_event == 'Обновить аватарку':
                file_path = sg.popup_get_file(
                    'Выберите новый аватар',
                    file_types=(("Изображения", "*.*"),)
                )
                if file_path:
                    try:
                        update_user_photo(current_user_id, file_path)
                        avatar_window['-CURRENT_AVATAR-'].update(filename=get_user_photo(current_user_id))
                        sg.popup('Аватар успешно обновлён!')
                    except Exception as e:
                        sg.popup(f'Ошибка обновления аватара: {e}')

        avatar_window.close()

    # Получаем активные диалоги
    active_dialogs = get_active_dialogs(current_user_id)

    # Создаем начальное окно
    visible_window = refresh_visible_window(active_dialogs)

    while True:
        event, values = visible_window.read(timeout=500)

        if event == sg.WINDOW_CLOSED:
            break

        # Обновление времени
        visible_window['-CURRENT_TIME-'].update(
            datetime.now(pytz.timezone("Europe/Moscow")).strftime('%H:%M:%S')
        )
        # Обновление чата
        refresh_chat()

        if event == 'Выбрать диалог':
            selected_user = select_dialog_window(current_user_id)
            if selected_user:
                visible_window['-DIALOG_HEADER-'].update(f'Диалог с: {selected_user[1]}#{selected_user[0]}')
                chat_history = get_chat_history(current_user_id, selected_user[0])
                chat_text = '\n'.join(
                    [
                        f"[{convert_utc_to_local(msg[2])}] {selected_user[1] if msg[0] == selected_user[0] else 'Вы'}: {msg[1]}"
                        for msg in chat_history]
                )
                visible_window['-CHAT-'].update(chat_text)


        elif event == 'Отправить':
            if selected_user and values['-MESSAGE-']:
                send_message(current_user_id, selected_user[0], values['-MESSAGE-'])
                visible_window['-MESSAGE-'].update('')

        elif event == 'Информация о себе':
            update_avatar_window(current_user_id, username)

            # После закрытия окна информации о себе нужно перерисовать главное окно
            visible_window.refresh()

    delete_temp_files()
    visible_window.close()

if __name__ == '__main__':
    main_menu()
